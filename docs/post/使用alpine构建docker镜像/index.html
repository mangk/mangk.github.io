<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用alpine构建Docker镜像 | 🥳</title>
<meta name=keywords content="Golang"><meta name=description content="序 最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：通过make构建golang程序、dockerfile不能访问父级目录、使用Alpine作为基础来制作我的容器镜像
通过Makefile打包Golang程序 什么是Makefile 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。
关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏） 阮一峰的网络日志-Make命令教程
Golang项目使用Makefile 我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target<目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。
示例代码 .PHONY: build clean run # golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows) OS=linux BUILD_DOCKER_IMAGE=0 all: build run: go run ./cmd/main.go build: # 下面的GOOS=$(OS)使用了上面定义的OS变量 @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy && GOOS=$(OS) go build -o app main.go # if判断中同样可以使用变量 ifeq ($(BUILD_DOCKER_IMAGE),1) @cd deploy && docker build -t . endif clean: # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端 rm app ifeq ($(BUILD_DOCKER_IMAGE),1) @docker rmi recommend_photo endif Dockerfile不能访问父级目录 项目汇中我使用Dockerfile作为构架docker镜像的基础。通过docker build -t image_name ."><meta name=author content="mangk"><link rel=canonical href=https://solobit.cn/post/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://solobit.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://solobit.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://solobit.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://solobit.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://solobit.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="使用alpine构建Docker镜像"><meta property="og:description" content="序 最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：通过make构建golang程序、dockerfile不能访问父级目录、使用Alpine作为基础来制作我的容器镜像
通过Makefile打包Golang程序 什么是Makefile 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。
关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏） 阮一峰的网络日志-Make命令教程
Golang项目使用Makefile 我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target<目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。
示例代码 .PHONY: build clean run # golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows) OS=linux BUILD_DOCKER_IMAGE=0 all: build run: go run ./cmd/main.go build: # 下面的GOOS=$(OS)使用了上面定义的OS变量 @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy && GOOS=$(OS) go build -o app main.go # if判断中同样可以使用变量 ifeq ($(BUILD_DOCKER_IMAGE),1) @cd deploy && docker build -t . endif clean: # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端 rm app ifeq ($(BUILD_DOCKER_IMAGE),1) @docker rmi recommend_photo endif Dockerfile不能访问父级目录 项目汇中我使用Dockerfile作为构架docker镜像的基础。通过docker build -t image_name ."><meta property="og:type" content="article"><meta property="og:url" content="https://solobit.cn/post/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/"><meta property="og:image" content="https://solobit.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-09-27T11:21:51+00:00"><meta property="article:modified_time" content="2022-09-27T11:21:51+00:00"><meta property="og:site_name" content="🥳"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://solobit.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="使用alpine构建Docker镜像"><meta name=twitter:description content="序 最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：通过make构建golang程序、dockerfile不能访问父级目录、使用Alpine作为基础来制作我的容器镜像
通过Makefile打包Golang程序 什么是Makefile 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。
关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏） 阮一峰的网络日志-Make命令教程
Golang项目使用Makefile 我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target<目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。
示例代码 .PHONY: build clean run # golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows) OS=linux BUILD_DOCKER_IMAGE=0 all: build run: go run ./cmd/main.go build: # 下面的GOOS=$(OS)使用了上面定义的OS变量 @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy && GOOS=$(OS) go build -o app main.go # if判断中同样可以使用变量 ifeq ($(BUILD_DOCKER_IMAGE),1) @cd deploy && docker build -t . endif clean: # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端 rm app ifeq ($(BUILD_DOCKER_IMAGE),1) @docker rmi recommend_photo endif Dockerfile不能访问父级目录 项目汇中我使用Dockerfile作为构架docker镜像的基础。通过docker build -t image_name ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://solobit.cn/post/"},{"@type":"ListItem","position":2,"name":"使用alpine构建Docker镜像","item":"https://solobit.cn/post/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用alpine构建Docker镜像","name":"使用alpine构建Docker镜像","description":"序 最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：通过make构建golang程序、dockerfile不能访问父级目录、使用Alpine作为基础来制作我的容器镜像\n通过Makefile打包Golang程序 什么是Makefile 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。\n关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏） 阮一峰的网络日志-Make命令教程\nGolang项目使用Makefile 我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target\u0026lt;目标\u0026gt;可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。\n示例代码 .PHONY: build clean run # golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows) OS=linux BUILD_DOCKER_IMAGE=0 all: build run: go run ./cmd/main.go build: # 下面的GOOS=$(OS)使用了上面定义的OS变量 @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy \u0026amp;\u0026amp; GOOS=$(OS) go build -o app main.go # if判断中同样可以使用变量 ifeq ($(BUILD_DOCKER_IMAGE),1) @cd deploy \u0026amp;\u0026amp; docker build -t . endif clean: # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端 rm app ifeq ($(BUILD_DOCKER_IMAGE),1) @docker rmi recommend_photo endif Dockerfile不能访问父级目录 项目汇中我使用Dockerfile作为构架docker镜像的基础。通过docker build -t image_name .","keywords":["Golang"],"articleBody":"序 最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：通过make构建golang程序、dockerfile不能访问父级目录、使用Alpine作为基础来制作我的容器镜像\n通过Makefile打包Golang程序 什么是Makefile 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。\n关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏） 阮一峰的网络日志-Make命令教程\nGolang项目使用Makefile 我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target\u003c目标\u003e可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。\n示例代码 .PHONY: build clean run # golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows) OS=linux BUILD_DOCKER_IMAGE=0 all: build run: go run ./cmd/main.go build: # 下面的GOOS=$(OS)使用了上面定义的OS变量 @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy \u0026\u0026 GOOS=$(OS) go build -o app main.go # if判断中同样可以使用变量 ifeq ($(BUILD_DOCKER_IMAGE),1) @cd deploy \u0026\u0026 docker build -t . endif clean: # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端 rm app ifeq ($(BUILD_DOCKER_IMAGE),1) @docker rmi recommend_photo endif Dockerfile不能访问父级目录 项目汇中我使用Dockerfile作为构架docker镜像的基础。通过docker build -t image_name .可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得COPY无法找到对应的文件，在查阅docker build命令后，发现可以通过-f选项来执行相关目录。\n我的目录结构 . ├── README.md ├── cmd │ └── main.go ├── conf │ ├── ... ├── deploy │ └── Dockerfile ├── http │ ├── ... ├── model │ ├── ... ├── makefile ├── go.mod ├── go.sum ├── config.yaml ├── sample.config.yaml 解决Dockerbuild目录可见性问题（使用 -f 选项） docker与dockerfile的关系这里不再阐述。这只单独介绍docker build-f选项的使用\n➜ project git:(dev) docker build -h Flag shorthand -h has been deprecated, please use --help Usage: docker build [OPTIONS] PATH | URL | - Build an image from a Dockerfile Options: --add-host list Add a custom host-to-IP mapping (host:ip) --build-arg list Set build-time variables --cache-from strings Images to consider as cache sources --disable-content-trust Skip image verification (default true) -f, --file string Name of the Dockerfile (Default is 'PATH/Dockerfile') ... 平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里-f选项就可以使用了：\ndocker build -t name:tag -f deploy/Dockerfile ./deploy -f选项指定了Dockerfile所在的目录，最后的./deploy是docker构建使用的根目录\n向Dockerfile中传递编译参数 通过-build-arg {ARG_NAME}={value}可以传递参数，那么在dockerfile中，通过arg 定义的变量可以接收到传递到参数ARG ARG_NAME=hello\n使用Alpine作为基础来制作我的容器镜像 Docker打包出的镜像超过1G让我不能接受 在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。 作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容\nAlpine镜像是什么 Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 https://pkgs.alpinelinux.org/packages 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。\n将golang编译与docker打包拆分 为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI/CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件app(可执行文件) \u0026 config.yaml。而我的镜像也变成了精简的49MB\n制作镜像时遇到的问题 可是当我使用镜像构建容器的时候，却总是提示\n➜ project git:(dev) docker run -it --rm 351b4d544b4e exec /app/app: no such file or directory 开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过docker save imageID \u003e filename.tar的方式将镜像下载到本地，然后解压去查找对应的文件，发现/app/app可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法)：\n镜像中存在可执行文件但是报错no such file or directory 由于golang构建与docker基于alpine打包分开 我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。 解决方案一般有两种：\n改为静态编译 如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED=0 ）或者在alpine中编译一个依赖MUSL LIBC的版本 追求精简的我选择了第一种静态编译 同时也实测简单的指定CGO_ENABLED=0并不完全解决问题\nalpine时区问题 有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:\npanic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory Init mysql error: unknown time zone Asia/Shanghai 常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。 所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了\nFROM alpine:latest WORKDIR /app ENV TZ Asia/Shanghai RUN apk update \u0026\u0026 apk add tzdata RUN cp /usr/share/zoneinfo/${TZ} /etc/localtime \\ \u0026\u0026 echo ${TZ} \u003e /etc/timezone ... 以上，解决了我这次项目中的问题。\n本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：https://juejin.cn/post/7053450610386468894\n","wordCount":"320","inLanguage":"en","datePublished":"2022-09-27T11:21:51Z","dateModified":"2022-09-27T11:21:51Z","author":{"@type":"Person","name":"mangk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://solobit.cn/post/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/"},"publisher":{"@type":"Organization","name":"🥳","logo":{"@type":"ImageObject","url":"https://solobit.cn/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://solobit.cn/ accesskey=h title="修猫工厂总部 (Alt + H)"><img src=https://solobit.cn/apple-touch-icon.png alt aria-label=logo height=35>修猫工厂总部</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://solobit.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://solobit.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://solobit.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://solobit.cn/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://solobit.cn/>Home</a>&nbsp;»&nbsp;<a href=https://solobit.cn/post/>Posts</a></div><h1 class="post-title entry-hint-parent">使用alpine构建Docker镜像</h1><div class=post-meta><span title='2022-09-27 11:21:51 +0000 UTC'>2022/09/27</span>&nbsp;·&nbsp;mangk</div></header><div class=post-content><h2 id=序>序<a hidden class=anchor aria-hidden=true href=#序>#</a></h2><p>最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：<a href=#%E9%80%9A%E8%BF%87Makefile%E6%89%93%E5%8C%85Golang%E7%A8%8B%E5%BA%8F>通过make构建golang程序</a>、<a href=#Dockerfile%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BA%A7%E7%9B%AE%E5%BD%95>dockerfile不能访问父级目录</a>、<a href=#%E4%BD%BF%E7%94%A8Alpine%E4%BD%9C%E4%B8%BA%E5%9F%BA%E7%A1%80%E6%9D%A5%E5%88%B6%E4%BD%9C%E6%88%91%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F>使用Alpine作为基础来制作我的容器镜像</a></p><h1 id=通过makefile打包golang程序>通过Makefile打包Golang程序<a hidden class=anchor aria-hidden=true href=#通过makefile打包golang程序>#</a></h1><h2 id=什么是makefile>什么是Makefile<a hidden class=anchor aria-hidden=true href=#什么是makefile>#</a></h2><blockquote><p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><p>关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏）
<a href=https://www.ruanyifeng.com/blog/2015/02/make.html>阮一峰的网络日志-Make命令教程</a></p></blockquote><h2 id=golang项目使用makefile>Golang项目使用Makefile<a hidden class=anchor aria-hidden=true href=#golang项目使用makefile>#</a></h2><p>我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target&lt;目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。</p><h3 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>build</span> <span class=n>clean</span> <span class=n>run</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>OS</span><span class=o>=</span>linux
</span></span><span class=line><span class=cl><span class=nv>BUILD_DOCKER_IMAGE</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>build</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>run</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    go run ./cmd/main.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>build</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 下面的GOOS=$(OS)使用了上面定义的OS变量</span>
</span></span><span class=line><span class=cl>    @GO111MODULE<span class=o>=</span>on <span class=nv>GOPROXY</span><span class=o>=</span>https://goproxy.cn,direct <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>0</span> go mod tidy <span class=o>&amp;&amp;</span> <span class=nv>GOOS</span><span class=o>=</span><span class=k>$(</span>OS<span class=k>)</span> go build -o app main.go
</span></span><span class=line><span class=cl><span class=c># if判断中同样可以使用变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>BUILD_DOCKER_IMAGE</span><span class=k>)</span><span class=err>,1)</span>
</span></span><span class=line><span class=cl>    <span class=err>@cd</span> <span class=err>deploy</span> <span class=err>&amp;&amp;</span> <span class=err>docker</span> <span class=err>build</span> <span class=err>-t</span> <span class=err>.</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端</span>
</span></span><span class=line><span class=cl>    rm app
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>BUILD_DOCKER_IMAGE</span><span class=k>)</span><span class=err>,1)</span>
</span></span><span class=line><span class=cl>    <span class=err>@docker</span> <span class=err>rmi</span> <span class=err>recommend_photo</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h1 id=dockerfile不能访问父级目录>Dockerfile不能访问父级目录<a hidden class=anchor aria-hidden=true href=#dockerfile不能访问父级目录>#</a></h1><p>项目汇中我使用Dockerfile作为构架docker镜像的基础。通过<code>docker build -t image_name .</code>可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得<code>COPY</code>无法找到对应的文件，在查阅<code>docker build</code>命令后，发现可以通过<code>-f</code>选项来执行相关目录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>我的目录结构
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── README.md
</span></span><span class=line><span class=cl>├── cmd
</span></span><span class=line><span class=cl>│   └── main.go
</span></span><span class=line><span class=cl>├── conf
</span></span><span class=line><span class=cl>│   ├── ...
</span></span><span class=line><span class=cl>├── deploy
</span></span><span class=line><span class=cl>│   └── Dockerfile
</span></span><span class=line><span class=cl>├── http
</span></span><span class=line><span class=cl>│   ├── ...
</span></span><span class=line><span class=cl>├── model
</span></span><span class=line><span class=cl>│   ├── ...
</span></span><span class=line><span class=cl>├── makefile
</span></span><span class=line><span class=cl>├── go.mod
</span></span><span class=line><span class=cl>├── go.sum
</span></span><span class=line><span class=cl>├── config.yaml
</span></span><span class=line><span class=cl>├── sample.config.yaml
</span></span></code></pre></div><h2 id=解决dockerbuild目录可见性问题使用--f-选项>解决Dockerbuild目录可见性问题（使用 -f 选项）<a hidden class=anchor aria-hidden=true href=#解决dockerbuild目录可见性问题使用--f-选项>#</a></h2><p>docker与dockerfile的关系这里不再阐述。这只单独介绍docker build<code>-f</code>选项的使用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>➜  project git:<span class=o>(</span>dev<span class=o>)</span> docker build -h   
</span></span><span class=line><span class=cl>Flag shorthand -h has been deprecated, please use --help
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Usage:  docker build <span class=o>[</span>OPTIONS<span class=o>]</span> PATH <span class=p>|</span> URL <span class=p>|</span> -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Build an image from a Dockerfile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Options:
</span></span><span class=line><span class=cl>      --add-host list           Add a custom host-to-IP mapping <span class=o>(</span>host:ip<span class=o>)</span>
</span></span><span class=line><span class=cl>      --build-arg list          Set build-time variables
</span></span><span class=line><span class=cl>      --cache-from strings      Images to consider as cache sources
</span></span><span class=line><span class=cl>      --disable-content-trust   Skip image verification <span class=o>(</span>default <span class=nb>true</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  -f, --file string             Name of the Dockerfile <span class=o>(</span>Default is <span class=s1>&#39;PATH/Dockerfile&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  ...
</span></span></code></pre></div><p>平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里<code>-f</code>选项就可以使用了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  docker build -t name:tag  -f deploy/Dockerfile ./deploy
</span></span></code></pre></div><p><code>-f</code>选项指定了Dockerfile所在的目录，最后的<code>./deploy</code>是docker构建使用的根目录</p><h2 id=向dockerfile中传递编译参数>向Dockerfile中传递编译参数<a hidden class=anchor aria-hidden=true href=#向dockerfile中传递编译参数>#</a></h2><p>通过<code>-build-arg {ARG_NAME}={value}</code>可以传递参数，那么在dockerfile中，通过<code>arg</code> 定义的变量可以接收到传递到参数<code>ARG ARG_NAME=hello</code></p><h1 id=使用alpine作为基础来制作我的容器镜像>使用Alpine作为基础来制作我的容器镜像<a hidden class=anchor aria-hidden=true href=#使用alpine作为基础来制作我的容器镜像>#</a></h1><h2 id=docker打包出的镜像超过1g让我不能接受>Docker打包出的镜像超过1G让我不能接受<a hidden class=anchor aria-hidden=true href=#docker打包出的镜像超过1g让我不能接受>#</a></h2><p>在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。
作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容</p><h2 id=alpine镜像是什么>Alpine镜像是什么<a hidden class=anchor aria-hidden=true href=#alpine镜像是什么>#</a></h2><blockquote><p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 <a href=https://pkgs.alpinelinux.org/packages>https://pkgs.alpinelinux.org/packages</a> 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。</p></blockquote><h2 id=将golang编译与docker打包拆分>将golang编译与docker打包拆分<a hidden class=anchor aria-hidden=true href=#将golang编译与docker打包拆分>#</a></h2><p>为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI/CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件<code>app(可执行文件) & config.yaml</code>。而我的镜像也变成了精简的49MB</p><h2 id=制作镜像时遇到的问题>制作镜像时遇到的问题<a hidden class=anchor aria-hidden=true href=#制作镜像时遇到的问题>#</a></h2><p>可是当我使用镜像构建容器的时候，却总是提示</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>➜  project git:<span class=o>(</span>dev<span class=o>)</span> docker run -it --rm 351b4d544b4e
</span></span><span class=line><span class=cl><span class=nb>exec</span> /app/app: no such file or directory
</span></span></code></pre></div><p>开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过<code>docker save imageID > filename.tar</code>的方式将镜像下载到本地，然后解压去查找对应的文件，发现<code>/app/app</code>可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自<a href=https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html>使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法</a>)：</p><h2 id=镜像中存在可执行文件但是报错no-such-file-or-directory>镜像中存在可执行文件但是报错no such file or directory<a hidden class=anchor aria-hidden=true href=#镜像中存在可执行文件但是报错no-such-file-or-directory>#</a></h2><p>由于golang构建与docker基于alpine打包分开
我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。
解决方案一般有两种：</p><blockquote><ul><li>改为静态编译</li><li>如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED=0 ）或者在alpine中编译一个依赖MUSL LIBC的版本</li></ul></blockquote><p>追求精简的我选择了第一种<a href=https://juejin.cn/post/7053450610386468894>静态编译</a>
同时也实测简单的指定<code>CGO_ENABLED=0</code>并不完全解决问题</p><h2 id=alpine时区问题>alpine时区问题<a hidden class=anchor aria-hidden=true href=#alpine时区问题>#</a></h2><p>有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Init mysql error: unknown <span class=nb>time</span> zone Asia/Shanghai
</span></span></code></pre></div><p>常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。
所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>FROM alpine:latest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>WORKDIR /app
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ENV TZ Asia/Shanghai
</span></span><span class=line><span class=cl>RUN apk update <span class=o>&amp;&amp;</span> apk add tzdata
</span></span><span class=line><span class=cl>RUN cp /usr/share/zoneinfo/<span class=si>${</span><span class=nv>TZ</span><span class=si>}</span> /etc/localtime <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> <span class=nb>echo</span> <span class=si>${</span><span class=nv>TZ</span><span class=si>}</span> &gt; /etc/timezone
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>以上，解决了我这次项目中的问题。</p><p>本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：https://juejin.cn/post/7053450610386468894</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://solobit.cn/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://solobit.cn/post/docker-swarm%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%BF%E7%94%A8/><span class=title>« Prev</span><br><span>docker swarm集群的使用</span>
</a><a class=next href=https://solobit.cn/post/golang-embed%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/><span class=title>Next »</span><br><span>Golang-embed包的使用</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://solobit.cn/>🥳</a></span>
|
<span><a href=https://beian.miit.gov.cn/ target=_blank>冀ICP备17019241号-4</a>
</span>|
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><span id=busuanzi_container_site_pv>访问<span id=busuanzi_value_site_pv></span>
</span>|
<span id=busuanzi_container_site_uv>访客<span id=busuanzi_value_site_uv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>