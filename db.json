{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-aomori/source/dist/build.css","path":"dist/build.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/dist/build.js","path":"dist/build.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/dist/custom.css","path":"dist/custom.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/dist/custom.js","path":"dist/custom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/app.js","path":"javascripts/app.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/class-module.js","path":"javascripts/class-module.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/custom.js","path":"javascripts/custom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/disqusjs.js","path":"javascripts/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/gitalk.js","path":"javascripts/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/valine.js","path":"javascripts/valine.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/algoliasearch-lite.umd.js","path":"modules/algoliasearch-lite.umd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/highlight.min.js","path":"modules/highlight.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/lazyload.min.js","path":"modules/lazyload.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/md5.min.js","path":"modules/md5.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/nprogress.js","path":"modules/nprogress.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/perfect-scrollbar.min.js","path":"modules/perfect-scrollbar.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/plyr.js","path":"modules/plyr.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/swiper-bundle.min.js","path":"modules/swiper-bundle.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/tocbot.min.js","path":"modules/tocbot.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/modules/typed.min.js","path":"modules/typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/base.scss","path":"stylesheets/base.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/github.css","path":"stylesheets/github.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/media-fixed.scss","path":"stylesheets/media-fixed.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/normalize.css","path":"stylesheets/normalize.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/nprogress.css","path":"stylesheets/nprogress.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/page.scss","path":"stylesheets/page.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/perfect-scrollbar.css","path":"stylesheets/perfect-scrollbar.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/plyr.css","path":"stylesheets/plyr.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/post.css","path":"stylesheets/post.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/remark42.css","path":"stylesheets/remark42.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre-exp.min.css","path":"stylesheets/spectre-exp.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre-icons.min.css","path":"stylesheets/spectre-icons.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre.min.css","path":"stylesheets/spectre.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/style.scss","path":"stylesheets/style.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/swiper-bundle.min.css","path":"stylesheets/swiper-bundle.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/tocbot.css","path":"stylesheets/tocbot.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1699857951143},{"_id":"node_modules/hexo-theme-aomori/.babelrc","hash":"98714b5432f56c788e08a5194f2f33148da6ca63","modified":1699858209189},{"_id":"node_modules/hexo-theme-aomori/CHANGELOG.md","hash":"45e3f28e7a4085134630a77b499670a8bcac6df1","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/LICENSE","hash":"df86e662005fc659cb72166664f8360223c10864","modified":1699858209191},{"_id":"node_modules/hexo-theme-aomori/.prettierrc","hash":"8f8d09c16c9623c6e0a5d8f22b64292ee98a5a4c","modified":1699858209190},{"_id":"node_modules/hexo-theme-aomori/.eslintrc.js","hash":"7d4dd8cabb411820feb1bfebb14992255fe2b714","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/README.md","hash":"9284588f3d73b808fef81ae9eb1544658ee036e0","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/_config.yml","hash":"7b06be8d7fdf7f3849c29d2b9904e57095069ba4","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/gulpfile.js","hash":"029ff69b9df64bf205ba5b2880e40f09fa1d2177","modified":1699858209207},{"_id":"node_modules/hexo-theme-aomori/.eslintignore","hash":"0d8193103ddb9947903ebb5204cf1e188902f1f8","modified":1699858209190},{"_id":"node_modules/hexo-theme-aomori/package.json","hash":"694d645c6702d16d45607ab2f0ed65f165c968f6","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/stylelint.config.js","hash":"35805e8a64447c3e9fec8cb7ca619783b4ffa4af","modified":1699858209208},{"_id":"node_modules/hexo-theme-aomori/languages/it.yml","hash":"64a5acadfdcd365474ba1161041f8c5938f59683","modified":1699858209211},{"_id":"node_modules/hexo-theme-aomori/languages/cn.yml","hash":"041cda235156e1a078c27b969cadc4e29d017475","modified":1699858209211},{"_id":"node_modules/hexo-theme-aomori/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1699858209198},{"_id":"node_modules/hexo-theme-aomori/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/layout.ejs","hash":"c5dd66db0cea3796abda36146ab38f061c91f39e","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/page.ejs","hash":"5e77fecc752e7baa7ce5ac57162980202160811d","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/post.ejs","hash":"f80a3073ea72631a26292ba16906b6d692a6e67c","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/index.ejs","hash":"ca9a6b1e5d2d952757671637156c5d72e6a0cb13","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/languages/ja.yml","hash":"90a615a4f6e9af92ec7695022c475ff4ce3b8081","modified":1699858209211},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/article-index.ejs","hash":"a436624e8aeb8c94113566cb1756e5c031cf5d8d","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/archive-post.ejs","hash":"74371ea0ece20630f686459a3df334b760c6bc55","modified":1699858209198},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/article.ejs","hash":"64fd49d64394a8a91030a56012a0131ee113d0a8","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/head.ejs","hash":"b4fe8c26c41ecb03e666ef9fa45aae43c420bd38","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/footer.ejs","hash":"f3366e3e0363de14099c6bf97727e844abe1f04b","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/header.ejs","hash":"29618017302e56fcb0bcc3a6487bacf6cb668086","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/article-tweet.ejs","hash":"67045e6d5d4bf141ad3e8a2bf34624ca5938e626","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/archive.ejs","hash":"f15750967beb06d91491aade0b4b00cb76a37dc9","modified":1699858209198},{"_id":"node_modules/hexo-theme-aomori/.github/dependabot.yml","hash":"7e68a5fac86d2eb86706b9ec9e99bd0ce00c15b0","modified":1699858209211},{"_id":"node_modules/hexo-theme-aomori/.github/workflows/action.yml","hash":"da59ad2d1d153ec97069cd74b920ea2e44d8ce3a","modified":1699858209211},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/meta.ejs","hash":"c8c71be685e412afbd8e9b25262e22f483f5e729","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/search.ejs","hash":"1569fd207c3be44ad37b644fb1399416a54779d3","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/sidebar.ejs","hash":"0f049afead13cf54b5e2f3174379d7a79eac0efe","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/_widget/recent_posts.ejs","hash":"d45e8c7b9c7fec1b8fdeabaa5026f27da0a04304","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_widget/category.ejs","hash":"70bba3e81f42135ffeb2d129834fd5df8aea4c10","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_widget/archive.ejs","hash":"4d00993c9f80ddbce6d4b8317d4c29a4fb1fb139","modified":1699858209198},{"_id":"node_modules/hexo-theme-aomori/layout/_widget/tag.ejs","hash":"e45f32b6c1b3a23c361d2c7dc70207d93c0f71b1","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/social.ejs","hash":"3ab80663dee0f4e3ae33ec4f42874530c7e926ec","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/_widget/toc.ejs","hash":"05a8cea96817332d13bf3ede759e6f72ed0f7973","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/custom.js","hash":"b186b1ae8921a3bf4d8746ac5f39acc10269ff96","modified":1699858209206},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/disqusjs.js","hash":"1152117cee4e335306b79983573721aeb6418d39","modified":1699858209206},{"_id":"node_modules/hexo-theme-aomori/source/dist/custom.css","hash":"225a8abab79b67565badb8d8e9dd73f56537ba28","modified":1699858209194},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/app.js","hash":"6bf67a2221f0dce645467ec0e83f30a242730f39","modified":1699858209203},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/class-module.js","hash":"a771801e8e5528130a947958f605f9fc4c6d913d","modified":1699858209205},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/gitalk.js","hash":"b2b847d6a4b8866f1a21896ab34b94adc607c6b4","modified":1699858209207},{"_id":"node_modules/hexo-theme-aomori/source/modules/lazyload.min.js","hash":"e7efa869cd842c2becc8337dd9cc445cd0fa5000","modified":1699858209207},{"_id":"node_modules/hexo-theme-aomori/source/modules/algoliasearch-lite.umd.js","hash":"bcd46b678c70779298df8ffad570ab14e434d292","modified":1699858209203},{"_id":"node_modules/hexo-theme-aomori/source/modules/nprogress.js","hash":"14757ab1fcf209a4f17c9da3d6abb196fa65cba2","modified":1699858209208},{"_id":"node_modules/hexo-theme-aomori/source/modules/md5.min.js","hash":"ab074f76aa161e2851e19733d802a66c9a242387","modified":1699858209207},{"_id":"node_modules/hexo-theme-aomori/source/modules/perfect-scrollbar.min.js","hash":"cd1784e029249ebf5d57de1f677a4a61019706ae","modified":1699858209208},{"_id":"node_modules/hexo-theme-aomori/source/javascripts/valine.js","hash":"64a97abf6fb7291bccda74f108b5661a9694ebef","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/source/modules/typed.min.js","hash":"ad8a75bd4743122b5dbf517221506607588ec50b","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/source/modules/tocbot.min.js","hash":"76cd7f7ae727d3883d69a04a4402a46684e4d4d0","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1699858209194},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/base.scss","hash":"a26efbbdcf15e8d6e3c044e733294fc6e8bedc77","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/nprogress.css","hash":"af66636e02bccfe2fdf7c1ad7de1face9bf5ae2d","modified":1699858209195},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/media-fixed.scss","hash":"4b0ff31517a8a3106cf227d85ec305b346cfa69b","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/normalize.css","hash":"ebe0759bf259b6caeadee6137973481046ac5636","modified":1699858209194},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/perfect-scrollbar.css","hash":"a94e730430930b2e048352996ff44bf28647669d","modified":1699858209195},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/plyr.css","hash":"89c8e024bad75eec921898cae702785d77272dda","modified":1699858209195},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/remark42.css","hash":"b12749bacee85f203fcd10afd9212838ffef06f3","modified":1699858209196},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre-exp.min.css","hash":"9ca686024f1e3c742a488156e8fcf4f7f5518425","modified":1699858209196},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/post.css","hash":"3f06ce944c9f721cdb5ea26c96fa11f9c2f6ec2f","modified":1699858209196},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre-icons.min.css","hash":"0f624fe521e0eb6c1f775f13eb0fb93ab6cf802c","modified":1699858209196},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/spectre.min.css","hash":"419c87aed0f592239f2adcbb6396731c6a7711cc","modified":1699858209197},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/style.scss","hash":"613fdeba6d7c7a2746e572ede464cd4db42ac570","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/swiper-bundle.min.css","hash":"a1fd2a708504af70216469cbd582cf698db8e461","modified":1699858209197},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/tocbot.css","hash":"635010b494dae3d91d3be1b079b72b26ab2cc5b8","modified":1699858209197},{"_id":"node_modules/hexo-theme-aomori/source/stylesheets/page.scss","hash":"57c6874a0520cb31f2295e5d75c8dabde066b478","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/page/friends.ejs","hash":"514e137c0e19e06dd3e930a98e5569cf83446b0a","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/page/default.ejs","hash":"23e0039aeba6413b99319fad4cea4e225aab38a1","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/page/photography-item.ejs","hash":"a6c1097d3428110825ca106c1379f2cd8034057f","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/copyright.ejs","hash":"4f1f566351a2ddff3f44f854a58f65ba6b28072c","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/date.ejs","hash":"c610dc1283e5d6ae582b9544ee6836e9fcea1b7c","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/ad.ejs","hash":"0a8130bcec7879f830976858b8d0dfe0ba036c01","modified":1699858209197},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/nav.ejs","hash":"d86028403ef9a098747712dc3103ed69c5089daa","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/comments.ejs","hash":"1502b23d5520b5db6c31c8036187f5373b4eb794","modified":1699858209199},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/refer.ejs","hash":"cc1e673e1054b62da356fc066e048b084a03559a","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/gallery.ejs","hash":"4502ca02780f3054cfaa517c9946d8c0479966cb","modified":1699858209200},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/reprint.ejs","hash":"75e9c766d19cb0907214e5628e00868b2adb6dcb","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1699858209202},{"_id":"node_modules/hexo-theme-aomori/layout/_partial/page/photography.ejs","hash":"6a71806820a4d92082d307a0e4dc67976d4038c4","modified":1699858209201},{"_id":"node_modules/hexo-theme-aomori/source/modules/highlight.min.js","hash":"5c25af3caf3f02695741a4b989fedcca6cc1e88d","modified":1699858209207},{"_id":"node_modules/hexo-theme-aomori/source/modules/plyr.js","hash":"6bce9267aa6e64f77973f7079cea430d88befca1","modified":1699858209208},{"_id":"node_modules/hexo-theme-aomori/docs/cover.png","hash":"f52354acc7e9e52efcafc2c33e41a4907c541055","modified":1699858209210},{"_id":"node_modules/hexo-theme-aomori/source/dist/build.css","hash":"d08b3ac3ce76582649bf4445c62c99011e3d5583","modified":1699858209193},{"_id":"node_modules/hexo-theme-aomori/source/dist/custom.js","hash":"d7679202f697b6547c456c08bab4edc9b76faaf4","modified":1699858209206},{"_id":"node_modules/hexo-theme-aomori/source/modules/swiper-bundle.min.js","hash":"72bd612182b6c475aa3d896231341a87da680ecb","modified":1699858209209},{"_id":"node_modules/hexo-theme-aomori/source/dist/build.js","hash":"f359132db8fdf12f4d9220cd42ce718c466d0d04","modified":1699858209205},{"_id":"source/_posts/Golang-GUI开发总结.md","hash":"1dbf424d1063cedca4147c07433c3892874a86e0","modified":1699858253657},{"_id":"source/_posts/Golang构建桌面程序之webview.md","hash":"5bc3dcad79af7128f881cea15917adb0f28ac442","modified":1699858253661},{"_id":"source/_posts/Golang-embed包的使用.md","hash":"9b17554a44241172f7465cb148a925c8eb833be7","modified":1699858253651},{"_id":"source/_posts/NFC基础知识与读写.md","hash":"0e7afa8572c6dc0a336a5816b9aad7c1edad79ee","modified":1699858253667},{"_id":"source/_posts/docker-swarm集群的使用.md","hash":"893e92ef36215afd3cc58e49730b7970b017f846","modified":1699858253645},{"_id":"source/_posts/小程序wx-navigateTo中的闭包.md","hash":"7326b463d5d77f2f9623db6b974bfe3feb265412","modified":1699858253634},{"_id":"source/about/index.md","hash":"53ab719d6ef257c7f22566508fff4f1826148c2a","modified":1699858268253},{"_id":"source/_posts/使用alpine构建docker镜像.md","hash":"556aaeae5cb9a2c69ea64e42b0820981c335e728","modified":1699858253627},{"_id":"source/_posts/免费泛域名SSL证书.md","hash":"6c9928ec9d15ea4683738764e118cf7cf1e0b1ae","modified":1699858253618},{"_id":"source/_posts/最近更新.md","hash":"4539e58ee2e308d971e51c80f9809209a508f436","modified":1699858253641},{"_id":"public/about/index.html","hash":"29fe663db0cf36df23a4493dd0cf23692cb7b8f9","modified":1699858343351},{"_id":"public/2023/11/02/小程序wx-navigateTo中的闭包/index.html","hash":"77b9e2fec61c79e593cdc322ada8098c7e20a5f7","modified":1699858343351},{"_id":"public/2023/03/09/免费泛域名SSL证书/index.html","hash":"f08c1eab9a327a38effd11f498b1749cfadf6a07","modified":1699858343351},{"_id":"public/2022/11/03/Golang-embed包的使用/index.html","hash":"4655b54705d67b9816a216e48017552d5c50da8d","modified":1699858343351},{"_id":"public/2022/11/03/Golang-GUI开发总结/index.html","hash":"2ac095ae658aa197c52042d2491e947dee6a22f1","modified":1699858343351},{"_id":"public/2022/11/03/Golang构建桌面程序之webview/index.html","hash":"f219e80c037d7a683d4c5aa7d1c8b209f3b81dbd","modified":1699858343351},{"_id":"public/2022/09/30/docker-swarm集群的使用/index.html","hash":"ea5a366b6defbf0c59264524013be6abd518c484","modified":1699858343351},{"_id":"public/1970/01/01/最近更新/index.html","hash":"bd5bc54356a5ed388905ed2b0c0410286d79d5eb","modified":1699858343351},{"_id":"public/archives/index.html","hash":"15a645e17803dc963878ef12df2800a48657039a","modified":1699858343351},{"_id":"public/archives/1970/index.html","hash":"93503e031b810d7ca1964a2ebd0848d78377d3fe","modified":1699858343351},{"_id":"public/archives/1970/01/index.html","hash":"f5a1746dfd301d8592585fe58536c1e1ffd4f8a5","modified":1699858343351},{"_id":"public/archives/2022/index.html","hash":"f75a10e7b23a28b999b254447344e7e43f3ca30d","modified":1699858343351},{"_id":"public/archives/2022/09/index.html","hash":"a2e7ad05efde3e196ce30452905e8f08e57c3cb2","modified":1699858343351},{"_id":"public/archives/2022/11/index.html","hash":"e7902c678e8c269cd54ddf9900544e0c5da6ee97","modified":1699858343351},{"_id":"public/archives/2023/index.html","hash":"e02e6753120e503c428df89e47afbd3ff8f2690a","modified":1699858343351},{"_id":"public/archives/2023/03/index.html","hash":"274881b58b4bb729a52772c5f183d161cbc4cf23","modified":1699858343351},{"_id":"public/archives/2023/11/index.html","hash":"a06abd6be9dfc0c5df9688cee38d29ad4eea2acc","modified":1699858343351},{"_id":"public/categories/Docker/index.html","hash":"2c3ad883de7b0b69d1190169651a830bef482061","modified":1699858343351},{"_id":"public/categories/小程序/index.html","hash":"84414a1e6af2196155cd9b22983c0f0e1599299f","modified":1699858343351},{"_id":"public/categories/Golang/index.html","hash":"221a417f7e5fab5f98f6ff03ec9049fab874d97c","modified":1699858343351},{"_id":"public/tags/Server/index.html","hash":"66edcf96062a46f3e881ad8f62b5245bae16ada1","modified":1699858343351},{"_id":"public/tags/Golang/index.html","hash":"45fbce37536a16cabe9a9edc1fa05c5d3361a44e","modified":1699858343351},{"_id":"public/tags/embed/index.html","hash":"30f966d511428af338ea83286f66c3b4a6e5f5ad","modified":1699858343351},{"_id":"public/tags/GUI/index.html","hash":"cb0cddc7d4fcdc155ec21acdb28f4816064cbfc7","modified":1699858343351},{"_id":"public/tags/webview/index.html","hash":"8b8a3507c81b97da0418cea5dc7dec5eb1671685","modified":1699858343351},{"_id":"public/tags/vue/index.html","hash":"2b2a29d5a7ab47a83775f23e02411a345916c9f1","modified":1699858343351},{"_id":"public/tags/gin/index.html","hash":"f880dba1b77413d687f6ca38f5cb3bf4f1b67898","modified":1699858343351},{"_id":"public/tags/NFC/index.html","hash":"9073342ce381f8dd07403a973b8ed97fa124d389","modified":1699858343351},{"_id":"public/tags/Ndef/index.html","hash":"017d85e1d60477bcfbb20c181904c8a216d14298","modified":1699858343351},{"_id":"public/tags/MifareClassic/index.html","hash":"9f68328546a2de488b54c4f86fef318bfa7742a5","modified":1699858343351},{"_id":"public/2022/11/18/NFC基础知识与读写/index.html","hash":"6148443f2a5bb18271e89def6d35bd11f1a5707d","modified":1699858343351},{"_id":"public/2022/09/27/使用alpine构建docker镜像/index.html","hash":"4c603e2856d72f32fc1685e490bec4765cf89b26","modified":1699858343351},{"_id":"public/index.html","hash":"11f188f06982cd4536b797b058cd83db782fb9b7","modified":1699858343351},{"_id":"public/page/2/index.html","hash":"599d4b4d093a3e831d7a8a39f36dc1aa3e41b9e9","modified":1699858343351},{"_id":"public/page/3/index.html","hash":"fd140fc5f82456199a905c8e9cb99fdd3861e4e6","modified":1699858343351},{"_id":"public/stylesheets/page.scss","hash":"57c6874a0520cb31f2295e5d75c8dabde066b478","modified":1699858343351},{"_id":"public/stylesheets/base.scss","hash":"a26efbbdcf15e8d6e3c044e733294fc6e8bedc77","modified":1699858343351},{"_id":"public/stylesheets/media-fixed.scss","hash":"4b0ff31517a8a3106cf227d85ec305b346cfa69b","modified":1699858343351},{"_id":"public/stylesheets/style.scss","hash":"613fdeba6d7c7a2746e572ede464cd4db42ac570","modified":1699858343351},{"_id":"public/javascripts/app.js","hash":"6bf67a2221f0dce645467ec0e83f30a242730f39","modified":1699858343351},{"_id":"public/javascripts/class-module.js","hash":"a771801e8e5528130a947958f605f9fc4c6d913d","modified":1699858343351},{"_id":"public/javascripts/disqusjs.js","hash":"1152117cee4e335306b79983573721aeb6418d39","modified":1699858343351},{"_id":"public/javascripts/gitalk.js","hash":"b2b847d6a4b8866f1a21896ab34b94adc607c6b4","modified":1699858343351},{"_id":"public/javascripts/valine.js","hash":"64a97abf6fb7291bccda74f108b5661a9694ebef","modified":1699858343351},{"_id":"public/javascripts/custom.js","hash":"b186b1ae8921a3bf4d8746ac5f39acc10269ff96","modified":1699858343351},{"_id":"public/modules/md5.min.js","hash":"ab074f76aa161e2851e19733d802a66c9a242387","modified":1699858343351},{"_id":"public/modules/algoliasearch-lite.umd.js","hash":"bcd46b678c70779298df8ffad570ab14e434d292","modified":1699858343351},{"_id":"public/modules/lazyload.min.js","hash":"a9b706094ef95a2f4ce0ec6eef0181951c5a7208","modified":1699858343351},{"_id":"public/modules/nprogress.js","hash":"14757ab1fcf209a4f17c9da3d6abb196fa65cba2","modified":1699858343351},{"_id":"public/modules/tocbot.min.js","hash":"76cd7f7ae727d3883d69a04a4402a46684e4d4d0","modified":1699858343351},{"_id":"public/modules/typed.min.js","hash":"ad8a75bd4743122b5dbf517221506607588ec50b","modified":1699858343351},{"_id":"public/stylesheets/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1699858343351},{"_id":"public/stylesheets/nprogress.css","hash":"af66636e02bccfe2fdf7c1ad7de1face9bf5ae2d","modified":1699858343351},{"_id":"public/stylesheets/normalize.css","hash":"ebe0759bf259b6caeadee6137973481046ac5636","modified":1699858343351},{"_id":"public/dist/build.css","hash":"d08b3ac3ce76582649bf4445c62c99011e3d5583","modified":1699858343351},{"_id":"public/dist/custom.css","hash":"225a8abab79b67565badb8d8e9dd73f56537ba28","modified":1699858343351},{"_id":"public/dist/build.js","hash":"a36f7dc0df1c252b2f407ceed1bb2bd6f31ba2ce","modified":1699858343351},{"_id":"public/dist/custom.js","hash":"d7679202f697b6547c456c08bab4edc9b76faaf4","modified":1699858343351},{"_id":"public/modules/highlight.min.js","hash":"5c25af3caf3f02695741a4b989fedcca6cc1e88d","modified":1699858343351},{"_id":"public/modules/perfect-scrollbar.min.js","hash":"cd1784e029249ebf5d57de1f677a4a61019706ae","modified":1699858343351},{"_id":"public/modules/plyr.js","hash":"6bce9267aa6e64f77973f7079cea430d88befca1","modified":1699858343351},{"_id":"public/stylesheets/perfect-scrollbar.css","hash":"a94e730430930b2e048352996ff44bf28647669d","modified":1699858343351},{"_id":"public/stylesheets/remark42.css","hash":"b12749bacee85f203fcd10afd9212838ffef06f3","modified":1699858343351},{"_id":"public/stylesheets/post.css","hash":"3f06ce944c9f721cdb5ea26c96fa11f9c2f6ec2f","modified":1699858343351},{"_id":"public/stylesheets/swiper-bundle.min.css","hash":"a1fd2a708504af70216469cbd582cf698db8e461","modified":1699858343351},{"_id":"public/stylesheets/spectre-icons.min.css","hash":"0f624fe521e0eb6c1f775f13eb0fb93ab6cf802c","modified":1699858343351},{"_id":"public/stylesheets/tocbot.css","hash":"635010b494dae3d91d3be1b079b72b26ab2cc5b8","modified":1699858343351},{"_id":"public/modules/swiper-bundle.min.js","hash":"72bd612182b6c475aa3d896231341a87da680ecb","modified":1699858343351},{"_id":"public/stylesheets/plyr.css","hash":"89c8e024bad75eec921898cae702785d77272dda","modified":1699858343351},{"_id":"public/stylesheets/spectre-exp.min.css","hash":"9ca686024f1e3c742a488156e8fcf4f7f5518425","modified":1699858343351},{"_id":"public/stylesheets/spectre.min.css","hash":"419c87aed0f592239f2adcbb6396731c6a7711cc","modified":1699858343351}],"Category":[{"name":"Docker","_id":"clowjpr1h0003ikfyamqxc95n"},{"name":"小程序","_id":"clowjpr1k0007ikfy2c6s67oy"},{"name":"Golang","_id":"clowjpr1k000bikfy5mfz5pon"}],"Data":[],"Page":[{"title":"About","date":"2022-09-21T14:21:41.000Z","layout":"about","sidebar":false,"_content":"\n## 这是我的第N+1个站点\n我是新时代的农民工、口号学家、喜欢晒网的摸鱼员工、感动中国特别奖获奖嘉宾。但从来不是一个合格的程序员。所以工作几年时间一直也没能沉淀点东西。这次借着兴致又起来了，我创建了这个站点，并希望未来能在这里记录下遇到的问题，或者是留下点什么有意思的东西。\n## 工作这些年\n从毕业到现在也有近5年的时间了，大部分期望是没有达到的。唯独开发这件事我还一直做着。确实喜欢，再就是现在只有这门手艺能混口饭吃。在某音看有500万就可以在小城市自由了。很好！还差490多万...我得加油！\n\n以前一直想着进个大厂。但从最近这段时间的经历来看，一是我的能力还差得远，二是大厂里也会有人渣并不一定总能如愿。但好在我现在有一份让自己满意的工作。那就也加油吧！\n\n>先这样，以后想到啥再来补充（2022-09-21 22:38）\n\n*** ","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-09-21 22:21:41\nlayout: about\nsidebar: false\n---\n\n## 这是我的第N+1个站点\n我是新时代的农民工、口号学家、喜欢晒网的摸鱼员工、感动中国特别奖获奖嘉宾。但从来不是一个合格的程序员。所以工作几年时间一直也没能沉淀点东西。这次借着兴致又起来了，我创建了这个站点，并希望未来能在这里记录下遇到的问题，或者是留下点什么有意思的东西。\n## 工作这些年\n从毕业到现在也有近5年的时间了，大部分期望是没有达到的。唯独开发这件事我还一直做着。确实喜欢，再就是现在只有这门手艺能混口饭吃。在某音看有500万就可以在小城市自由了。很好！还差490多万...我得加油！\n\n以前一直想着进个大厂。但从最近这段时间的经历来看，一是我的能力还差得远，二是大厂里也会有人渣并不一定总能如愿。但好在我现在有一份让自己满意的工作。那就也加油吧！\n\n>先这样，以后想到啥再来补充（2022-09-21 22:38）\n\n*** ","updated":"2023-11-13T06:51:08.253Z","path":"about/index.html","_id":"clowjq2co0019ikfybbtc4v92","comments":1,"content":"<h2 id=\"这是我的第N-1个站点\"><a href=\"#这是我的第N-1个站点\" class=\"headerlink\" title=\"这是我的第N+1个站点\"></a>这是我的第N+1个站点</h2><p>我是新时代的农民工、口号学家、喜欢晒网的摸鱼员工、感动中国特别奖获奖嘉宾。但从来不是一个合格的程序员。所以工作几年时间一直也没能沉淀点东西。这次借着兴致又起来了，我创建了这个站点，并希望未来能在这里记录下遇到的问题，或者是留下点什么有意思的东西。</p>\n<h2 id=\"工作这些年\"><a href=\"#工作这些年\" class=\"headerlink\" title=\"工作这些年\"></a>工作这些年</h2><p>从毕业到现在也有近5年的时间了，大部分期望是没有达到的。唯独开发这件事我还一直做着。确实喜欢，再就是现在只有这门手艺能混口饭吃。在某音看有500万就可以在小城市自由了。很好！还差490多万…我得加油！</p>\n<p>以前一直想着进个大厂。但从最近这段时间的经历来看，一是我的能力还差得远，二是大厂里也会有人渣并不一定总能如愿。但好在我现在有一份让自己满意的工作。那就也加油吧！</p>\n<blockquote>\n<p>先这样，以后想到啥再来补充（2022-09-21 22:38）</p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"这是我的第N-1个站点\"><a href=\"#这是我的第N-1个站点\" class=\"headerlink\" title=\"这是我的第N+1个站点\"></a>这是我的第N+1个站点</h2><p>我是新时代的农民工、口号学家、喜欢晒网的摸鱼员工、感动中国特别奖获奖嘉宾。但从来不是一个合格的程序员。所以工作几年时间一直也没能沉淀点东西。这次借着兴致又起来了，我创建了这个站点，并希望未来能在这里记录下遇到的问题，或者是留下点什么有意思的东西。</p>\n<h2 id=\"工作这些年\"><a href=\"#工作这些年\" class=\"headerlink\" title=\"工作这些年\"></a>工作这些年</h2><p>从毕业到现在也有近5年的时间了，大部分期望是没有达到的。唯独开发这件事我还一直做着。确实喜欢，再就是现在只有这门手艺能混口饭吃。在某音看有500万就可以在小城市自由了。很好！还差490多万…我得加油！</p>\n<p>以前一直想着进个大厂。但从最近这段时间的经历来看，一是我的能力还差得远，二是大厂里也会有人渣并不一定总能如愿。但好在我现在有一份让自己满意的工作。那就也加油吧！</p>\n<blockquote>\n<p>先这样，以后想到啥再来补充（2022-09-21 22:38）</p>\n</blockquote>\n<hr>\n"}],"Post":[{"title":"Docker Swarm集群的使用","comments":1,"banner_img_height":30,"date":"2022-09-30T04:48:35.000Z","_content":"## 序\n咱们书接[上回](/2022/09/27/使用alpine构建docker镜像/)，我搞定了golang程序的编译，搞定了docker镜像的打包，搞定了流水线。现在项目部署与热更新成了我要面对的问题。\n受制于公司提供的部署环境（只提供给我一台主机，主机上有docker），我暂时没有k8s集群可用，但又希望能完成基于流水线的自动部署、热更新和不停机更新。所以返现了下面要说的`docker swarm`\n\n## 什么是 swarm mode\nSwarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。具体内容可以参见：[基本概念](https://yeasy.gitbook.io/docker_practice/swarm_mode/overview)，这里不再详细解释。\n\n## 集群创建\n``` shell\ndocker swarm init\nSwarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \\\n    192.168.99.100:2377\n\nTo add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.\n```\n使用`docker swarm init`命令，创建一个集群，本机的docker就会变成一个单节点的集群。","source":"_posts/docker-swarm集群的使用.md","raw":"---\ntitle: docker swarm集群的使用\ncomments: true\nbanner_img_height: 30\ndate: 2022-09-30 12:48:35\ncategories:\n- Docker\ntags:\n---\n## 序\n咱们书接[上回](/2022/09/27/使用alpine构建docker镜像/)，我搞定了golang程序的编译，搞定了docker镜像的打包，搞定了流水线。现在项目部署与热更新成了我要面对的问题。\n受制于公司提供的部署环境（只提供给我一台主机，主机上有docker），我暂时没有k8s集群可用，但又希望能完成基于流水线的自动部署、热更新和不停机更新。所以返现了下面要说的`docker swarm`\n\n## 什么是 swarm mode\nSwarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。具体内容可以参见：[基本概念](https://yeasy.gitbook.io/docker_practice/swarm_mode/overview)，这里不再详细解释。\n\n## 集群创建\n``` shell\ndocker swarm init\nSwarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join \\\n    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \\\n    192.168.99.100:2377\n\nTo add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.\n```\n使用`docker swarm init`命令，创建一个集群，本机的docker就会变成一个单节点的集群。","slug":"docker-swarm集群的使用","published":1,"updated":"2023-11-13T06:50:53.645Z","_id":"clowjpr1f0001ikfydx19cn3x","layout":"post","photos":[],"content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>咱们书接<a href=\"/2022/09/27/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/\">上回</a>，我搞定了golang程序的编译，搞定了docker镜像的打包，搞定了流水线。现在项目部署与热更新成了我要面对的问题。<br>受制于公司提供的部署环境（只提供给我一台主机，主机上有docker），我暂时没有k8s集群可用，但又希望能完成基于流水线的自动部署、热更新和不停机更新。所以返现了下面要说的<code>docker swarm</code></p>\n<h2 id=\"什么是-swarm-mode\"><a href=\"#什么是-swarm-mode\" class=\"headerlink\" title=\"什么是 swarm mode\"></a>什么是 swarm mode</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。具体内容可以参见：<a href=\"https://yeasy.gitbook.io/docker_practice/swarm_mode/overview\">基本概念</a>，这里不再详细解释。</p>\n<h2 id=\"集群创建\"><a href=\"#集群创建\" class=\"headerlink\" title=\"集群创建\"></a>集群创建</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm init</span><br><span class=\"line\">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</span><br><span class=\"line\"></span><br><span class=\"line\">To add a worker to this swarm, run the following command:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm join \\</span><br><span class=\"line\">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \\</span><br><span class=\"line\">    192.168.99.100:2377</span><br><span class=\"line\"></span><br><span class=\"line\">To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span><br></pre></td></tr></table></figure>\n<p>使用<code>docker swarm init</code>命令，创建一个集群，本机的docker就会变成一个单节点的集群。</p>\n","excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>咱们书接<a href=\"/2022/09/27/%E4%BD%BF%E7%94%A8alpine%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/\">上回</a>，我搞定了golang程序的编译，搞定了docker镜像的打包，搞定了流水线。现在项目部署与热更新成了我要面对的问题。<br>受制于公司提供的部署环境（只提供给我一台主机，主机上有docker），我暂时没有k8s集群可用，但又希望能完成基于流水线的自动部署、热更新和不停机更新。所以返现了下面要说的<code>docker swarm</code></p>\n<h2 id=\"什么是-swarm-mode\"><a href=\"#什么是-swarm-mode\" class=\"headerlink\" title=\"什么是 swarm mode\"></a>什么是 swarm mode</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。具体内容可以参见：<a href=\"https://yeasy.gitbook.io/docker_practice/swarm_mode/overview\">基本概念</a>，这里不再详细解释。</p>\n<h2 id=\"集群创建\"><a href=\"#集群创建\" class=\"headerlink\" title=\"集群创建\"></a>集群创建</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker swarm init</span><br><span class=\"line\">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</span><br><span class=\"line\"></span><br><span class=\"line\">To add a worker to this swarm, run the following command:</span><br><span class=\"line\"></span><br><span class=\"line\">    docker swarm join \\</span><br><span class=\"line\">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \\</span><br><span class=\"line\">    192.168.99.100:2377</span><br><span class=\"line\"></span><br><span class=\"line\">To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span><br></pre></td></tr></table></figure>\n<p>使用<code>docker swarm init</code>命令，创建一个集群，本机的docker就会变成一个单节点的集群。</p>\n"},{"title":"免费泛域名SSL证书","comments":1,"banner_img_height":30,"date":"2023-03-09T11:20:34.000Z","_content":"# 使用acme.sh配置泛域名证书\n## 安装acme.sh\n### 安装\n```shell\ncurl https://get.acme.sh | sh -s email=youEmail@email.com\n```\n### 生成泛域名证书：\n1. 执行命令\n```shell\nacme.sh --issue --dns -d *.youDomin.com \\\n --yes-I-know-dns-manual-mode-enough-go-ahead-please\n```\n2. 这时候会输出生成如下内容\n```shell\nUsing CA: https://acme.zerossl.com/v2/DV90\nSingle domain='*.youDomin.com'\nGetting domain auth token for each domain\nGetting webroot for domain='*.youDomin.com'\nAdd the following TXT record:\nDomain: '_acme-challenge.youDomin.com'\nTXT value: 'fdlkajflajfkdlJFKLDSAJFLKJDSLKJF'\nPlease be aware that you prepend _acme-challenge. before your domain\nso the resulting subdomain will be: _acme-challenge.youDomin.com\nPlease add the TXT records to the domains, and re-run with --renew.\nPlease add '--debug' or '--log' to check more details.\nSee: https://github.com/acmesh-official/acme.sh/wiki/How-to-debug-acme.sh\n```\n去域名管理后台添加dns记录`_acme-challenge.youDomin.com`类型为`TXT`值为`fdlkajflajfkdlJFKLDSAJFLKJDSLKJF`\n3. 执行命令\n```shell\nacme.sh --renew -d *.youDomin.com --yes-I-know-dns-manual-mode-enough-go-ahead-please\n```\n完成验证。\n此时证书会被下载到服务器上\n### 配置nginx自动替换证书\n创建目录及文件`/etc/nginx/conf.d/ssl/key.pem`,`/etc/nginx/conf.d/ssl/cert.pem`\n```shell\nacme.sh --install-cert -d *.youDomin.com \\\n--key-file       /etc/nginx/conf.d/ssl/key.pem  \\\n--fullchain-file /etc/nginx/conf.d/ssl/cert.pem \\\n--reloadcmd     \"nginx -s reload\"\n```\n此时证书会被复制到`/etc/nginx/conf.d/ssl/`目录下。并自动通过命令`nginx -s reload`重启nginx。所以这里都要替换成自己真是的。\n### 这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx\n\n### 参见：[https://github.com/acmesh-official/acme.sh](https://github.com/acmesh-official/acme.sh)","source":"_posts/免费泛域名SSL证书.md","raw":"---\ntitle: 免费泛域名SSL证书\ncomments: true\nbanner_img_height: 30\ndate: 2023-03-09 19:20:34\ncategories:\ntags:\n- Server\n---\n# 使用acme.sh配置泛域名证书\n## 安装acme.sh\n### 安装\n```shell\ncurl https://get.acme.sh | sh -s email=youEmail@email.com\n```\n### 生成泛域名证书：\n1. 执行命令\n```shell\nacme.sh --issue --dns -d *.youDomin.com \\\n --yes-I-know-dns-manual-mode-enough-go-ahead-please\n```\n2. 这时候会输出生成如下内容\n```shell\nUsing CA: https://acme.zerossl.com/v2/DV90\nSingle domain='*.youDomin.com'\nGetting domain auth token for each domain\nGetting webroot for domain='*.youDomin.com'\nAdd the following TXT record:\nDomain: '_acme-challenge.youDomin.com'\nTXT value: 'fdlkajflajfkdlJFKLDSAJFLKJDSLKJF'\nPlease be aware that you prepend _acme-challenge. before your domain\nso the resulting subdomain will be: _acme-challenge.youDomin.com\nPlease add the TXT records to the domains, and re-run with --renew.\nPlease add '--debug' or '--log' to check more details.\nSee: https://github.com/acmesh-official/acme.sh/wiki/How-to-debug-acme.sh\n```\n去域名管理后台添加dns记录`_acme-challenge.youDomin.com`类型为`TXT`值为`fdlkajflajfkdlJFKLDSAJFLKJDSLKJF`\n3. 执行命令\n```shell\nacme.sh --renew -d *.youDomin.com --yes-I-know-dns-manual-mode-enough-go-ahead-please\n```\n完成验证。\n此时证书会被下载到服务器上\n### 配置nginx自动替换证书\n创建目录及文件`/etc/nginx/conf.d/ssl/key.pem`,`/etc/nginx/conf.d/ssl/cert.pem`\n```shell\nacme.sh --install-cert -d *.youDomin.com \\\n--key-file       /etc/nginx/conf.d/ssl/key.pem  \\\n--fullchain-file /etc/nginx/conf.d/ssl/cert.pem \\\n--reloadcmd     \"nginx -s reload\"\n```\n此时证书会被复制到`/etc/nginx/conf.d/ssl/`目录下。并自动通过命令`nginx -s reload`重启nginx。所以这里都要替换成自己真是的。\n### 这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx\n\n### 参见：[https://github.com/acmesh-official/acme.sh](https://github.com/acmesh-official/acme.sh)","slug":"免费泛域名SSL证书","published":1,"updated":"2023-11-13T06:50:53.618Z","_id":"clowjpr1g0002ikfyajld7o1e","layout":"post","photos":[],"content":"<h1 id=\"使用acme-sh配置泛域名证书\"><a href=\"#使用acme-sh配置泛域名证书\" class=\"headerlink\" title=\"使用acme.sh配置泛域名证书\"></a>使用acme.sh配置泛域名证书</h1><h2 id=\"安装acme-sh\"><a href=\"#安装acme-sh\" class=\"headerlink\" title=\"安装acme.sh\"></a>安装acme.sh</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://get.acme.sh | sh -s email=youEmail@email.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成泛域名证书：\"><a href=\"#生成泛域名证书：\" class=\"headerlink\" title=\"生成泛域名证书：\"></a>生成泛域名证书：</h3><ol>\n<li>执行命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue --dns -d *.youDomin.com \\</span><br><span class=\"line\"> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure></li>\n<li>这时候会输出生成如下内容<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using CA: https://acme.zerossl.com/v2/DV90</span><br><span class=\"line\">Single domain=&#x27;*.youDomin.com&#x27;</span><br><span class=\"line\">Getting domain auth token for each domain</span><br><span class=\"line\">Getting webroot for domain=&#x27;*.youDomin.com&#x27;</span><br><span class=\"line\">Add the following TXT record:</span><br><span class=\"line\">Domain: &#x27;_acme-challenge.youDomin.com&#x27;</span><br><span class=\"line\">TXT value: &#x27;fdlkajflajfkdlJFKLDSAJFLKJDSLKJF&#x27;</span><br><span class=\"line\">Please be aware that you prepend _acme-challenge. before your domain</span><br><span class=\"line\">so the resulting subdomain will be: _acme-challenge.youDomin.com</span><br><span class=\"line\">Please add the TXT records to the domains, and re-run with --renew.</span><br><span class=\"line\">Please add &#x27;--debug&#x27; or &#x27;--log&#x27; to check more details.</span><br><span class=\"line\">See: https://github.com/acmesh-official/acme.sh/wiki/How-to-debug-acme.sh</span><br></pre></td></tr></table></figure>\n去域名管理后台添加dns记录<code>_acme-challenge.youDomin.com</code>类型为<code>TXT</code>值为<code>fdlkajflajfkdlJFKLDSAJFLKJDSLKJF</code></li>\n<li>执行命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --renew -d *.youDomin.com --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>\n完成验证。<br>此时证书会被下载到服务器上</li>\n</ol>\n<h3 id=\"配置nginx自动替换证书\"><a href=\"#配置nginx自动替换证书\" class=\"headerlink\" title=\"配置nginx自动替换证书\"></a>配置nginx自动替换证书</h3><p>创建目录及文件<code>/etc/nginx/conf.d/ssl/key.pem</code>,<code>/etc/nginx/conf.d/ssl/cert.pem</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert -d *.youDomin.com \\</span><br><span class=\"line\">--key-file       /etc/nginx/conf.d/ssl/key.pem  \\</span><br><span class=\"line\">--fullchain-file /etc/nginx/conf.d/ssl/cert.pem \\</span><br><span class=\"line\">--reloadcmd     &quot;nginx -s reload&quot;</span><br></pre></td></tr></table></figure>\n<p>此时证书会被复制到<code>/etc/nginx/conf.d/ssl/</code>目录下。并自动通过命令<code>nginx -s reload</code>重启nginx。所以这里都要替换成自己真是的。</p>\n<h3 id=\"这样就算完成了，acme-sh创建的定时任务会自动续期证书并更新证书重启nginx\"><a href=\"#这样就算完成了，acme-sh创建的定时任务会自动续期证书并更新证书重启nginx\" class=\"headerlink\" title=\"这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx\"></a>这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx</h3><h3 id=\"参见：https-github-com-acmesh-official-acme-sh\"><a href=\"#参见：https-github-com-acmesh-official-acme-sh\" class=\"headerlink\" title=\"参见：https://github.com/acmesh-official/acme.sh\"></a>参见：<a href=\"https://github.com/acmesh-official/acme.sh\">https://github.com/acmesh-official/acme.sh</a></h3>","excerpt":"","more":"<h1 id=\"使用acme-sh配置泛域名证书\"><a href=\"#使用acme-sh配置泛域名证书\" class=\"headerlink\" title=\"使用acme.sh配置泛域名证书\"></a>使用acme.sh配置泛域名证书</h1><h2 id=\"安装acme-sh\"><a href=\"#安装acme-sh\" class=\"headerlink\" title=\"安装acme.sh\"></a>安装acme.sh</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://get.acme.sh | sh -s email=youEmail@email.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成泛域名证书：\"><a href=\"#生成泛域名证书：\" class=\"headerlink\" title=\"生成泛域名证书：\"></a>生成泛域名证书：</h3><ol>\n<li>执行命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue --dns -d *.youDomin.com \\</span><br><span class=\"line\"> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure></li>\n<li>这时候会输出生成如下内容<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using CA: https://acme.zerossl.com/v2/DV90</span><br><span class=\"line\">Single domain=&#x27;*.youDomin.com&#x27;</span><br><span class=\"line\">Getting domain auth token for each domain</span><br><span class=\"line\">Getting webroot for domain=&#x27;*.youDomin.com&#x27;</span><br><span class=\"line\">Add the following TXT record:</span><br><span class=\"line\">Domain: &#x27;_acme-challenge.youDomin.com&#x27;</span><br><span class=\"line\">TXT value: &#x27;fdlkajflajfkdlJFKLDSAJFLKJDSLKJF&#x27;</span><br><span class=\"line\">Please be aware that you prepend _acme-challenge. before your domain</span><br><span class=\"line\">so the resulting subdomain will be: _acme-challenge.youDomin.com</span><br><span class=\"line\">Please add the TXT records to the domains, and re-run with --renew.</span><br><span class=\"line\">Please add &#x27;--debug&#x27; or &#x27;--log&#x27; to check more details.</span><br><span class=\"line\">See: https://github.com/acmesh-official/acme.sh/wiki/How-to-debug-acme.sh</span><br></pre></td></tr></table></figure>\n去域名管理后台添加dns记录<code>_acme-challenge.youDomin.com</code>类型为<code>TXT</code>值为<code>fdlkajflajfkdlJFKLDSAJFLKJDSLKJF</code></li>\n<li>执行命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --renew -d *.youDomin.com --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>\n完成验证。<br>此时证书会被下载到服务器上</li>\n</ol>\n<h3 id=\"配置nginx自动替换证书\"><a href=\"#配置nginx自动替换证书\" class=\"headerlink\" title=\"配置nginx自动替换证书\"></a>配置nginx自动替换证书</h3><p>创建目录及文件<code>/etc/nginx/conf.d/ssl/key.pem</code>,<code>/etc/nginx/conf.d/ssl/cert.pem</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert -d *.youDomin.com \\</span><br><span class=\"line\">--key-file       /etc/nginx/conf.d/ssl/key.pem  \\</span><br><span class=\"line\">--fullchain-file /etc/nginx/conf.d/ssl/cert.pem \\</span><br><span class=\"line\">--reloadcmd     &quot;nginx -s reload&quot;</span><br></pre></td></tr></table></figure>\n<p>此时证书会被复制到<code>/etc/nginx/conf.d/ssl/</code>目录下。并自动通过命令<code>nginx -s reload</code>重启nginx。所以这里都要替换成自己真是的。</p>\n<h3 id=\"这样就算完成了，acme-sh创建的定时任务会自动续期证书并更新证书重启nginx\"><a href=\"#这样就算完成了，acme-sh创建的定时任务会自动续期证书并更新证书重启nginx\" class=\"headerlink\" title=\"这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx\"></a>这样就算完成了，acme.sh创建的定时任务会自动续期证书并更新证书重启nginx</h3><h3 id=\"参见：https-github-com-acmesh-official-acme-sh\"><a href=\"#参见：https-github-com-acmesh-official-acme-sh\" class=\"headerlink\" title=\"参见：https://github.com/acmesh-official/acme.sh\"></a>参见：<a href=\"https://github.com/acmesh-official/acme.sh\">https://github.com/acmesh-official/acme.sh</a></h3>"},{"title":"小程序wx.navigateTo中的闭包","comments":1,"banner_img_height":30,"date":"2023-11-02T10:04:38.000Z","_content":"\n# 序\n最近的开发任务中处理了这样一个情况:\n\n1. 打开小程序是从onLoad判断是否携带参数\n2. 判断用户是否登录\n3. 如果没有登录需要跳转登录并跳转回来\n4. 回来后继续使用(1)中携带的参数处理问题\n\n听起来没有什么难点，我们只需要设置`app.globleData`就可以很轻松的完成需求。但是我思考问题的点在于登录环节：如果每次有类似的需求都要去改动登录页的代码，那会让登录页面的`if`条件越来越多，代码可读性也会持续下降。\n\n于是我开始查找对登录页面修改最少的解决方案：\n- 使用`wx.router`来完成需求，但是我不是专业写前端的，而是被拉来救急的，让我去看文档写代码是在太慢了。而且如果整个小程序都改用`wx.router`，这其中的修改成本也太高了。\n- 使用`app.globleData`前面说了，也不太可取\n- 最终我发现了`wx.navigateTo`中的`success`可以处理我的问题。\n\n所以在这里将我的思路写下来做记录，也提供给有同样需求的人参考。\n\n# 还是要用到`app.globleData`\n\n是的，我的方式中还是要对`app.globleData`进行设置，但是约定了统一的格式，无论在哪个页面。\n```js\nvar pages = getCurrentPages()\nvar curPage = pages[pages.length-1]\n\napp.globleData.navigateInfo = {\n    url:\"/\"+curPage.route,\n    success: function (e) {\n        var page = getCurrentPages().pop()\n        if (page == undefined || page == null) return;\n        page.selectComponent(\"#coupon\").runCoupon();\n    }\n}\n```\n在登录页面只需要判断`app.globleData.navigateInfo`这一个参数，并在完成登录操作后直接将`navigateInfo对象`交给`wx.navigateTo`方法执行就跳回了原来的页面。\n\n这里面神奇的点在于可以直接执行组件中的某个方法\n\n","source":"_posts/小程序wx-navigateTo中的闭包.md","raw":"---\ntitle: 小程序wx.navigateTo中的闭包\ncomments: true\nbanner_img_height: 30\ndate: 2023-11-02 18:04:38\ncategories:\n- 小程序\ntags:\n---\n\n# 序\n最近的开发任务中处理了这样一个情况:\n\n1. 打开小程序是从onLoad判断是否携带参数\n2. 判断用户是否登录\n3. 如果没有登录需要跳转登录并跳转回来\n4. 回来后继续使用(1)中携带的参数处理问题\n\n听起来没有什么难点，我们只需要设置`app.globleData`就可以很轻松的完成需求。但是我思考问题的点在于登录环节：如果每次有类似的需求都要去改动登录页的代码，那会让登录页面的`if`条件越来越多，代码可读性也会持续下降。\n\n于是我开始查找对登录页面修改最少的解决方案：\n- 使用`wx.router`来完成需求，但是我不是专业写前端的，而是被拉来救急的，让我去看文档写代码是在太慢了。而且如果整个小程序都改用`wx.router`，这其中的修改成本也太高了。\n- 使用`app.globleData`前面说了，也不太可取\n- 最终我发现了`wx.navigateTo`中的`success`可以处理我的问题。\n\n所以在这里将我的思路写下来做记录，也提供给有同样需求的人参考。\n\n# 还是要用到`app.globleData`\n\n是的，我的方式中还是要对`app.globleData`进行设置，但是约定了统一的格式，无论在哪个页面。\n```js\nvar pages = getCurrentPages()\nvar curPage = pages[pages.length-1]\n\napp.globleData.navigateInfo = {\n    url:\"/\"+curPage.route,\n    success: function (e) {\n        var page = getCurrentPages().pop()\n        if (page == undefined || page == null) return;\n        page.selectComponent(\"#coupon\").runCoupon();\n    }\n}\n```\n在登录页面只需要判断`app.globleData.navigateInfo`这一个参数，并在完成登录操作后直接将`navigateInfo对象`交给`wx.navigateTo`方法执行就跳回了原来的页面。\n\n这里面神奇的点在于可以直接执行组件中的某个方法\n\n","slug":"小程序wx-navigateTo中的闭包","published":1,"updated":"2023-11-13T06:50:53.634Z","_id":"clowjpr1i0004ikfy7o2rdkqq","layout":"post","photos":[],"content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>最近的开发任务中处理了这样一个情况:</p>\n<ol>\n<li>打开小程序是从onLoad判断是否携带参数</li>\n<li>判断用户是否登录</li>\n<li>如果没有登录需要跳转登录并跳转回来</li>\n<li>回来后继续使用(1)中携带的参数处理问题</li>\n</ol>\n<p>听起来没有什么难点，我们只需要设置<code>app.globleData</code>就可以很轻松的完成需求。但是我思考问题的点在于登录环节：如果每次有类似的需求都要去改动登录页的代码，那会让登录页面的<code>if</code>条件越来越多，代码可读性也会持续下降。</p>\n<p>于是我开始查找对登录页面修改最少的解决方案：</p>\n<ul>\n<li>使用<code>wx.router</code>来完成需求，但是我不是专业写前端的，而是被拉来救急的，让我去看文档写代码是在太慢了。而且如果整个小程序都改用<code>wx.router</code>，这其中的修改成本也太高了。</li>\n<li>使用<code>app.globleData</code>前面说了，也不太可取</li>\n<li>最终我发现了<code>wx.navigateTo</code>中的<code>success</code>可以处理我的问题。</li>\n</ul>\n<p>所以在这里将我的思路写下来做记录，也提供给有同样需求的人参考。</p>\n<h1 id=\"还是要用到app-globleData\"><a href=\"#还是要用到app-globleData\" class=\"headerlink\" title=\"还是要用到app.globleData\"></a>还是要用到<code>app.globleData</code></h1><p>是的，我的方式中还是要对<code>app.globleData</code>进行设置，但是约定了统一的格式，无论在哪个页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = <span class=\"title function_\">getCurrentPages</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> curPage = pages[pages.<span class=\"property\">length</span>-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"property\">globleData</span>.<span class=\"property\">navigateInfo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>:<span class=\"string\">&quot;/&quot;</span>+curPage.<span class=\"property\">route</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> page = <span class=\"title function_\">getCurrentPages</span>().<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (page == <span class=\"literal\">undefined</span> || page == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        page.<span class=\"title function_\">selectComponent</span>(<span class=\"string\">&quot;#coupon&quot;</span>).<span class=\"title function_\">runCoupon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在登录页面只需要判断<code>app.globleData.navigateInfo</code>这一个参数，并在完成登录操作后直接将<code>navigateInfo对象</code>交给<code>wx.navigateTo</code>方法执行就跳回了原来的页面。</p>\n<p>这里面神奇的点在于可以直接执行组件中的某个方法</p>\n","excerpt":"","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>最近的开发任务中处理了这样一个情况:</p>\n<ol>\n<li>打开小程序是从onLoad判断是否携带参数</li>\n<li>判断用户是否登录</li>\n<li>如果没有登录需要跳转登录并跳转回来</li>\n<li>回来后继续使用(1)中携带的参数处理问题</li>\n</ol>\n<p>听起来没有什么难点，我们只需要设置<code>app.globleData</code>就可以很轻松的完成需求。但是我思考问题的点在于登录环节：如果每次有类似的需求都要去改动登录页的代码，那会让登录页面的<code>if</code>条件越来越多，代码可读性也会持续下降。</p>\n<p>于是我开始查找对登录页面修改最少的解决方案：</p>\n<ul>\n<li>使用<code>wx.router</code>来完成需求，但是我不是专业写前端的，而是被拉来救急的，让我去看文档写代码是在太慢了。而且如果整个小程序都改用<code>wx.router</code>，这其中的修改成本也太高了。</li>\n<li>使用<code>app.globleData</code>前面说了，也不太可取</li>\n<li>最终我发现了<code>wx.navigateTo</code>中的<code>success</code>可以处理我的问题。</li>\n</ul>\n<p>所以在这里将我的思路写下来做记录，也提供给有同样需求的人参考。</p>\n<h1 id=\"还是要用到app-globleData\"><a href=\"#还是要用到app-globleData\" class=\"headerlink\" title=\"还是要用到app.globleData\"></a>还是要用到<code>app.globleData</code></h1><p>是的，我的方式中还是要对<code>app.globleData</code>进行设置，但是约定了统一的格式，无论在哪个页面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = <span class=\"title function_\">getCurrentPages</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> curPage = pages[pages.<span class=\"property\">length</span>-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"property\">globleData</span>.<span class=\"property\">navigateInfo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>:<span class=\"string\">&quot;/&quot;</span>+curPage.<span class=\"property\">route</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> page = <span class=\"title function_\">getCurrentPages</span>().<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (page == <span class=\"literal\">undefined</span> || page == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        page.<span class=\"title function_\">selectComponent</span>(<span class=\"string\">&quot;#coupon&quot;</span>).<span class=\"title function_\">runCoupon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在登录页面只需要判断<code>app.globleData.navigateInfo</code>这一个参数，并在完成登录操作后直接将<code>navigateInfo对象</code>交给<code>wx.navigateTo</code>方法执行就跳回了原来的页面。</p>\n<p>这里面神奇的点在于可以直接执行组件中的某个方法</p>\n"},{"title":"Golang-Embed包的使用","comments":1,"banner_img_height":30,"date":"2022-11-03T09:02:56.000Z","_content":"有点懒还没来得及写","source":"_posts/Golang-embed包的使用.md","raw":"---\ntitle: Golang-embed包的使用\ncomments: true\nbanner_img_height: 30\ndate: 2022-11-3 17:02:56\ncategories:\n- Golang\ntags:\n- Golang\n- embed\n---\n有点懒还没来得及写","slug":"Golang-embed包的使用","published":1,"updated":"2023-11-13T06:50:53.651Z","_id":"clowjpr1j0006ikfya703cu50","layout":"post","photos":[],"content":"<p>有点懒还没来得及写</p>\n","excerpt":"","more":"<p>有点懒还没来得及写</p>\n"},{"title":"","comments":1,"banner_img_height":30,"date":"1969-12-31T16:00:00.000Z","sticky":200,"layout":"tweet","icon":"golf","_content":"\n# 解锁新的传送锚点 🥳\n","source":"_posts/最近更新.md","raw":"---\ntitle: \ncomments: true\nbanner_img_height: 30\ndate: 1970-01-01\ncategories:\ntags:\nsticky: 200\nlayout: tweet\nicon: golf\n---\n\n# 解锁新的传送锚点 🥳\n","slug":"最近更新","published":1,"updated":"2023-11-13T06:50:53.641Z","_id":"clowjpr1l000hikfy40ea558t","photos":[],"content":"<h1 id=\"解锁新的传送锚点-🥳\"><a href=\"#解锁新的传送锚点-🥳\" class=\"headerlink\" title=\"解锁新的传送锚点 🥳\"></a>解锁新的传送锚点 🥳</h1>","excerpt":"","more":"<h1 id=\"解锁新的传送锚点-🥳\"><a href=\"#解锁新的传送锚点-🥳\" class=\"headerlink\" title=\"解锁新的传送锚点 🥳\"></a>解锁新的传送锚点 🥳</h1>"},{"title":"使用alpine构建Docker镜像","comments":1,"date":"2022-09-27T03:21:51.000Z","banner_img_height":30,"_content":"\n## 序\n最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：[通过make构建golang程序](#通过Makefile打包Golang程序)、[dockerfile不能访问父级目录](#Dockerfile不能访问父级目录)、[使用Alpine作为基础来制作我的容器镜像](#使用Alpine作为基础来制作我的容器镜像)\n\n# 通过Makefile打包Golang程序\n## 什么是Makefile\n>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。\n>\n>关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏）\n> [阮一峰的网络日志-Make命令教程](https://www.ruanyifeng.com/blog/2015/02/make.html)\n## Golang项目使用Makefile\n我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target<目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。\n### 示例代码\n``` makefile\n.PHONY: build clean run\n\n# golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows)\nOS=linux\nBUILD_DOCKER_IMAGE=0\n\nall: build\n\nrun:\n    go run ./cmd/main.go\n\nbuild:\n    # 下面的GOOS=$(OS)使用了上面定义的OS变量\n    @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy && GOOS=$(OS) go build -o app main.go\n# if判断中同样可以使用变量\nifeq ($(BUILD_DOCKER_IMAGE),1)\n    @cd deploy && docker build -t .\nendif\n\nclean:\n    # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端\n    rm app\nifeq ($(BUILD_DOCKER_IMAGE),1)\n    @docker rmi recommend_photo\nendif\n```\n\n# Dockerfile不能访问父级目录\n项目汇中我使用Dockerfile作为构架docker镜像的基础。通过`docker build -t image_name .`可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得`COPY`无法找到对应的文件，在查阅`docker build`命令后，发现可以通过`-f`选项来执行相关目录。\n``` shell\n我的目录结构\n.\n├── README.md\n├── cmd\n│   └── main.go\n├── conf\n│   ├── ...\n├── deploy\n│   └── Dockerfile\n├── http\n│   ├── ...\n├── model\n│   ├── ...\n├── makefile\n├── go.mod\n├── go.sum\n├── config.yaml\n├── sample.config.yaml\n```\n## 解决Dockerbuild目录可见性问题（使用 -f 选项）\ndocker与dockerfile的关系这里不再阐述。这只单独介绍docker build`-f`选项的使用\n``` shell\n➜  project git:(dev) docker build -h   \nFlag shorthand -h has been deprecated, please use --help\n\nUsage:  docker build [OPTIONS] PATH | URL | -\n\nBuild an image from a Dockerfile\n\nOptions:\n      --add-host list           Add a custom host-to-IP mapping (host:ip)\n      --build-arg list          Set build-time variables\n      --cache-from strings      Images to consider as cache sources\n      --disable-content-trust   Skip image verification (default true)\n  -f, --file string             Name of the Dockerfile (Default is 'PATH/Dockerfile')\n  ...\n```\n平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里`-f`选项就可以使用了：\n``` shell\n  docker build -t name:tag  -f deploy/Dockerfile ./deploy\n```\n`-f`选项指定了Dockerfile所在的目录，最后的`./deploy`是docker构建使用的根目录\n\n## 向Dockerfile中传递编译参数\n通过`-build-arg {ARG_NAME}={value}`可以传递参数，那么在dockerfile中，通过`arg` 定义的变量可以接收到传递到参数`ARG ARG_NAME=hello`\n\n# 使用Alpine作为基础来制作我的容器镜像\n## Docker打包出的镜像超过1G让我不能接受\n在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。\n作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容\n## Alpine镜像是什么\n> Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 https://pkgs.alpinelinux.org/packages 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。\n## 将golang编译与docker打包拆分\n为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI/CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件`app(可执行文件) & config.yaml`。而我的镜像也变成了精简的49MB\n## 制作镜像时遇到的问题\n可是当我使用镜像构建容器的时候，却总是提示\n``` shell\n➜  project git:(dev) docker run -it --rm 351b4d544b4e\nexec /app/app: no such file or directory\n```\n开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过`docker save imageID > filename.tar`的方式将镜像下载到本地，然后解压去查找对应的文件，发现`/app/app`可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自[使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法](https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html))：\n\n## 镜像中存在可执行文件但是报错no such file or directory\n由于golang构建与docker基于alpine打包分开\n我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。\n解决方案一般有两种：\n> - 改为静态编译\n> - 如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED=0 ）或者在alpine中编译一个依赖MUSL LIBC的版本\n\n追求精简的我选择了第一种[静态编译](https://juejin.cn/post/7053450610386468894)\n同时也实测简单的指定`CGO_ENABLED=0`并不完全解决问题\n## alpine时区问题\n有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:\n``` shell\npanic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory\n\nInit mysql error: unknown time zone Asia/Shanghai\n```\n常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。\n所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了\n``` shell\nFROM alpine:latest\n\nWORKDIR /app\n\nENV TZ Asia/Shanghai\nRUN apk update && apk add tzdata\nRUN cp /usr/share/zoneinfo/${TZ} /etc/localtime \\\n    && echo ${TZ} > /etc/timezone\n...\n```\n\n以上，解决了我这次项目中的问题。\n\n本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：https://juejin.cn/post/7053450610386468894","source":"_posts/使用alpine构建docker镜像.md","raw":"---\ntitle: 使用alpine构建Docker镜像\ncomments: true\ndate: 2022-09-27 11:21:51\nbanner_img_height: 30\ncategories:\n- Docker\ntags:\n- Golang\n---\n\n## 序\n最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：[通过make构建golang程序](#通过Makefile打包Golang程序)、[dockerfile不能访问父级目录](#Dockerfile不能访问父级目录)、[使用Alpine作为基础来制作我的容器镜像](#使用Alpine作为基础来制作我的容器镜像)\n\n# 通过Makefile打包Golang程序\n## 什么是Makefile\n>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。\n>\n>关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏）\n> [阮一峰的网络日志-Make命令教程](https://www.ruanyifeng.com/blog/2015/02/make.html)\n## Golang项目使用Makefile\n我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target<目标>可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。\n### 示例代码\n``` makefile\n.PHONY: build clean run\n\n# golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows)\nOS=linux\nBUILD_DOCKER_IMAGE=0\n\nall: build\n\nrun:\n    go run ./cmd/main.go\n\nbuild:\n    # 下面的GOOS=$(OS)使用了上面定义的OS变量\n    @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy && GOOS=$(OS) go build -o app main.go\n# if判断中同样可以使用变量\nifeq ($(BUILD_DOCKER_IMAGE),1)\n    @cd deploy && docker build -t .\nendif\n\nclean:\n    # 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端\n    rm app\nifeq ($(BUILD_DOCKER_IMAGE),1)\n    @docker rmi recommend_photo\nendif\n```\n\n# Dockerfile不能访问父级目录\n项目汇中我使用Dockerfile作为构架docker镜像的基础。通过`docker build -t image_name .`可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得`COPY`无法找到对应的文件，在查阅`docker build`命令后，发现可以通过`-f`选项来执行相关目录。\n``` shell\n我的目录结构\n.\n├── README.md\n├── cmd\n│   └── main.go\n├── conf\n│   ├── ...\n├── deploy\n│   └── Dockerfile\n├── http\n│   ├── ...\n├── model\n│   ├── ...\n├── makefile\n├── go.mod\n├── go.sum\n├── config.yaml\n├── sample.config.yaml\n```\n## 解决Dockerbuild目录可见性问题（使用 -f 选项）\ndocker与dockerfile的关系这里不再阐述。这只单独介绍docker build`-f`选项的使用\n``` shell\n➜  project git:(dev) docker build -h   \nFlag shorthand -h has been deprecated, please use --help\n\nUsage:  docker build [OPTIONS] PATH | URL | -\n\nBuild an image from a Dockerfile\n\nOptions:\n      --add-host list           Add a custom host-to-IP mapping (host:ip)\n      --build-arg list          Set build-time variables\n      --cache-from strings      Images to consider as cache sources\n      --disable-content-trust   Skip image verification (default true)\n  -f, --file string             Name of the Dockerfile (Default is 'PATH/Dockerfile')\n  ...\n```\n平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里`-f`选项就可以使用了：\n``` shell\n  docker build -t name:tag  -f deploy/Dockerfile ./deploy\n```\n`-f`选项指定了Dockerfile所在的目录，最后的`./deploy`是docker构建使用的根目录\n\n## 向Dockerfile中传递编译参数\n通过`-build-arg {ARG_NAME}={value}`可以传递参数，那么在dockerfile中，通过`arg` 定义的变量可以接收到传递到参数`ARG ARG_NAME=hello`\n\n# 使用Alpine作为基础来制作我的容器镜像\n## Docker打包出的镜像超过1G让我不能接受\n在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。\n作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容\n## Alpine镜像是什么\n> Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 https://pkgs.alpinelinux.org/packages 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。\n## 将golang编译与docker打包拆分\n为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI/CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件`app(可执行文件) & config.yaml`。而我的镜像也变成了精简的49MB\n## 制作镜像时遇到的问题\n可是当我使用镜像构建容器的时候，却总是提示\n``` shell\n➜  project git:(dev) docker run -it --rm 351b4d544b4e\nexec /app/app: no such file or directory\n```\n开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过`docker save imageID > filename.tar`的方式将镜像下载到本地，然后解压去查找对应的文件，发现`/app/app`可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自[使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法](https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html))：\n\n## 镜像中存在可执行文件但是报错no such file or directory\n由于golang构建与docker基于alpine打包分开\n我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。\n解决方案一般有两种：\n> - 改为静态编译\n> - 如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED=0 ）或者在alpine中编译一个依赖MUSL LIBC的版本\n\n追求精简的我选择了第一种[静态编译](https://juejin.cn/post/7053450610386468894)\n同时也实测简单的指定`CGO_ENABLED=0`并不完全解决问题\n## alpine时区问题\n有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:\n``` shell\npanic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory\n\nInit mysql error: unknown time zone Asia/Shanghai\n```\n常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。\n所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了\n``` shell\nFROM alpine:latest\n\nWORKDIR /app\n\nENV TZ Asia/Shanghai\nRUN apk update && apk add tzdata\nRUN cp /usr/share/zoneinfo/${TZ} /etc/localtime \\\n    && echo ${TZ} > /etc/timezone\n...\n```\n\n以上，解决了我这次项目中的问题。\n\n本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：https://juejin.cn/post/7053450610386468894","slug":"使用alpine构建docker镜像","published":1,"updated":"2023-11-13T06:50:53.627Z","_id":"clowjpr1l000iikfy42cv623k","layout":"post","photos":[],"content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：<a href=\"#%E9%80%9A%E8%BF%87Makefile%E6%89%93%E5%8C%85Golang%E7%A8%8B%E5%BA%8F\">通过make构建golang程序</a>、<a href=\"#Dockerfile%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BA%A7%E7%9B%AE%E5%BD%95\">dockerfile不能访问父级目录</a>、<a href=\"#%E4%BD%BF%E7%94%A8Alpine%E4%BD%9C%E4%B8%BA%E5%9F%BA%E7%A1%80%E6%9D%A5%E5%88%B6%E4%BD%9C%E6%88%91%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F\">使用Alpine作为基础来制作我的容器镜像</a></p>\n<h1 id=\"通过Makefile打包Golang程序\"><a href=\"#通过Makefile打包Golang程序\" class=\"headerlink\" title=\"通过Makefile打包Golang程序\"></a>通过Makefile打包Golang程序</h1><h2 id=\"什么是Makefile\"><a href=\"#什么是Makefile\" class=\"headerlink\" title=\"什么是Makefile\"></a>什么是Makefile</h2><blockquote>\n<p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p>\n<p>关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏）<br><a href=\"https://www.ruanyifeng.com/blog/2015/02/make.html\">阮一峰的网络日志-Make命令教程</a></p>\n</blockquote>\n<h2 id=\"Golang项目使用Makefile\"><a href=\"#Golang项目使用Makefile\" class=\"headerlink\" title=\"Golang项目使用Makefile\"></a>Golang项目使用Makefile</h2><p>我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target&lt;目标&gt;可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。</p>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>: build clean run</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows)</span></span><br><span class=\"line\">OS=linux</span><br><span class=\"line\">BUILD_DOCKER_IMAGE=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: build</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">    go run ./cmd/main.go</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">build:</span></span><br><span class=\"line\">    <span class=\"comment\"># 下面的GOOS=$(OS)使用了上面定义的OS变量</span></span><br><span class=\"line\">    @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy &amp;&amp; GOOS=<span class=\"variable\">$(OS)</span> go build -o app main.go</span><br><span class=\"line\"><span class=\"comment\"># if判断中同样可以使用变量</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BUILD_DOCKER_IMAGE)</span>,1)</span><br><span class=\"line\">    @cd deploy &amp;&amp; docker build -t .</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">    <span class=\"comment\"># 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端</span></span><br><span class=\"line\">    rm app</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BUILD_DOCKER_IMAGE)</span>,1)</span><br><span class=\"line\">    @docker rmi recommend_photo</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dockerfile不能访问父级目录\"><a href=\"#Dockerfile不能访问父级目录\" class=\"headerlink\" title=\"Dockerfile不能访问父级目录\"></a>Dockerfile不能访问父级目录</h1><p>项目汇中我使用Dockerfile作为构架docker镜像的基础。通过<code>docker build -t image_name .</code>可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得<code>COPY</code>无法找到对应的文件，在查阅<code>docker build</code>命令后，发现可以通过<code>-f</code>选项来执行相关目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我的目录结构</span><br><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── cmd</span><br><span class=\"line\">│   └── main.go</span><br><span class=\"line\">├── conf</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── deploy</span><br><span class=\"line\">│   └── Dockerfile</span><br><span class=\"line\">├── http</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── model</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── makefile</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">├── go.sum</span><br><span class=\"line\">├── config.yaml</span><br><span class=\"line\">├── sample.config.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决Dockerbuild目录可见性问题（使用-f-选项）\"><a href=\"#解决Dockerbuild目录可见性问题（使用-f-选项）\" class=\"headerlink\" title=\"解决Dockerbuild目录可见性问题（使用 -f 选项）\"></a>解决Dockerbuild目录可见性问题（使用 -f 选项）</h2><p>docker与dockerfile的关系这里不再阐述。这只单独介绍docker build<code>-f</code>选项的使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  project git:(dev) docker build -h   </span><br><span class=\"line\">Flag shorthand -h has been deprecated, please use --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class=\"line\"></span><br><span class=\"line\">Build an image from a Dockerfile</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class=\"line\">      --build-arg list          Set build-time variables</span><br><span class=\"line\">      --cache-from strings      Images to consider as cache sources</span><br><span class=\"line\">      --disable-content-trust   Skip image verification (default true)</span><br><span class=\"line\">  -f, --file string             Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里<code>-f</code>选项就可以使用了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t name:tag  -f deploy/Dockerfile ./deploy</span><br></pre></td></tr></table></figure>\n<p><code>-f</code>选项指定了Dockerfile所在的目录，最后的<code>./deploy</code>是docker构建使用的根目录</p>\n<h2 id=\"向Dockerfile中传递编译参数\"><a href=\"#向Dockerfile中传递编译参数\" class=\"headerlink\" title=\"向Dockerfile中传递编译参数\"></a>向Dockerfile中传递编译参数</h2><p>通过<code>-build-arg &#123;ARG_NAME&#125;=&#123;value&#125;</code>可以传递参数，那么在dockerfile中，通过<code>arg</code> 定义的变量可以接收到传递到参数<code>ARG ARG_NAME=hello</code></p>\n<h1 id=\"使用Alpine作为基础来制作我的容器镜像\"><a href=\"#使用Alpine作为基础来制作我的容器镜像\" class=\"headerlink\" title=\"使用Alpine作为基础来制作我的容器镜像\"></a>使用Alpine作为基础来制作我的容器镜像</h1><h2 id=\"Docker打包出的镜像超过1G让我不能接受\"><a href=\"#Docker打包出的镜像超过1G让我不能接受\" class=\"headerlink\" title=\"Docker打包出的镜像超过1G让我不能接受\"></a>Docker打包出的镜像超过1G让我不能接受</h2><p>在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。<br>作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容</p>\n<h2 id=\"Alpine镜像是什么\"><a href=\"#Alpine镜像是什么\" class=\"headerlink\" title=\"Alpine镜像是什么\"></a>Alpine镜像是什么</h2><blockquote>\n<p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 <a href=\"https://pkgs.alpinelinux.org/packages\">https://pkgs.alpinelinux.org/packages</a> 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。</p>\n</blockquote>\n<h2 id=\"将golang编译与docker打包拆分\"><a href=\"#将golang编译与docker打包拆分\" class=\"headerlink\" title=\"将golang编译与docker打包拆分\"></a>将golang编译与docker打包拆分</h2><p>为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI&#x2F;CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件<code>app(可执行文件) &amp; config.yaml</code>。而我的镜像也变成了精简的49MB</p>\n<h2 id=\"制作镜像时遇到的问题\"><a href=\"#制作镜像时遇到的问题\" class=\"headerlink\" title=\"制作镜像时遇到的问题\"></a>制作镜像时遇到的问题</h2><p>可是当我使用镜像构建容器的时候，却总是提示</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  project git:(dev) docker run -it --rm 351b4d544b4e</span><br><span class=\"line\">exec /app/app: no such file or directory</span><br></pre></td></tr></table></figure>\n<p>开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过<code>docker save imageID &gt; filename.tar</code>的方式将镜像下载到本地，然后解压去查找对应的文件，发现<code>/app/app</code>可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自<a href=\"https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html\">使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法</a>)：</p>\n<h2 id=\"镜像中存在可执行文件但是报错no-such-file-or-directory\"><a href=\"#镜像中存在可执行文件但是报错no-such-file-or-directory\" class=\"headerlink\" title=\"镜像中存在可执行文件但是报错no such file or directory\"></a>镜像中存在可执行文件但是报错no such file or directory</h2><p>由于golang构建与docker基于alpine打包分开<br>我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。<br>解决方案一般有两种：</p>\n<blockquote>\n<ul>\n<li>改为静态编译</li>\n<li>如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED&#x3D;0 ）或者在alpine中编译一个依赖MUSL LIBC的版本</li>\n</ul>\n</blockquote>\n<p>追求精简的我选择了第一种<a href=\"https://juejin.cn/post/7053450610386468894\">静态编译</a><br>同时也实测简单的指定<code>CGO_ENABLED=0</code>并不完全解决问题</p>\n<h2 id=\"alpine时区问题\"><a href=\"#alpine时区问题\" class=\"headerlink\" title=\"alpine时区问题\"></a>alpine时区问题</h2><p>有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">Init mysql error: unknown time zone Asia/Shanghai</span><br></pre></td></tr></table></figure>\n<p>常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。<br>所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine:latest</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\"></span><br><span class=\"line\">ENV TZ Asia/Shanghai</span><br><span class=\"line\">RUN apk update &amp;&amp; apk add tzdata</span><br><span class=\"line\">RUN cp /usr/share/zoneinfo/$&#123;TZ&#125; /etc/localtime \\</span><br><span class=\"line\">    &amp;&amp; echo $&#123;TZ&#125; &gt; /etc/timezone</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>以上，解决了我这次项目中的问题。</p>\n<p>本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：<a href=\"https://juejin.cn/post/7053450610386468894\">https://juejin.cn/post/7053450610386468894</a></p>\n","excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近的工作中，我使用Golang开发了一个web项目，并准备通过流水线的方式做持续集成与发布。在这是用过程中遇到了一些技术与问题包括：<a href=\"#%E9%80%9A%E8%BF%87Makefile%E6%89%93%E5%8C%85Golang%E7%A8%8B%E5%BA%8F\">通过make构建golang程序</a>、<a href=\"#Dockerfile%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BA%A7%E7%9B%AE%E5%BD%95\">dockerfile不能访问父级目录</a>、<a href=\"#%E4%BD%BF%E7%94%A8Alpine%E4%BD%9C%E4%B8%BA%E5%9F%BA%E7%A1%80%E6%9D%A5%E5%88%B6%E4%BD%9C%E6%88%91%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F\">使用Alpine作为基础来制作我的容器镜像</a></p>\n<h1 id=\"通过Makefile打包Golang程序\"><a href=\"#通过Makefile打包Golang程序\" class=\"headerlink\" title=\"通过Makefile打包Golang程序\"></a>通过Makefile打包Golang程序</h1><h2 id=\"什么是Makefile\"><a href=\"#什么是Makefile\" class=\"headerlink\" title=\"什么是Makefile\"></a>什么是Makefile</h2><blockquote>\n<p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p>\n<p>关于make命令这里不做深入介绍，引用链接提供介绍清晰明了的直通车（让我们感谢大神🙏）<br><a href=\"https://www.ruanyifeng.com/blog/2015/02/make.html\">阮一峰的网络日志-Make命令教程</a></p>\n</blockquote>\n<h2 id=\"Golang项目使用Makefile\"><a href=\"#Golang项目使用Makefile\" class=\"headerlink\" title=\"Golang项目使用Makefile\"></a>Golang项目使用Makefile</h2><p>我对makefile文件的理解是它有点像时一个命令的集合，通过一个个target&lt;目标&gt;可以按照顺序快速的执行多条命令而不用再手动一条条输入。if else与变量的加入让这个流程变得更加丰富和多变。省去了命令输入的同时也让代码运行的流程更加清楚。</p>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>: build clean run</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># golang 打包可执行文件的运行环境 (可以在运行make命令时传入：make OS=windows)</span></span><br><span class=\"line\">OS=linux</span><br><span class=\"line\">BUILD_DOCKER_IMAGE=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: build</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">    go run ./cmd/main.go</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">build:</span></span><br><span class=\"line\">    <span class=\"comment\"># 下面的GOOS=$(OS)使用了上面定义的OS变量</span></span><br><span class=\"line\">    @GO111MODULE=on GOPROXY=https://goproxy.cn,direct CGO_ENABLED=0 go mod tidy &amp;&amp; GOOS=<span class=\"variable\">$(OS)</span> go build -o app main.go</span><br><span class=\"line\"><span class=\"comment\"># if判断中同样可以使用变量</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BUILD_DOCKER_IMAGE)</span>,1)</span><br><span class=\"line\">    @cd deploy &amp;&amp; docker build -t .</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">    <span class=\"comment\"># 命令前加@会让命令执行但不在控制台输出，这里没有@命令执行时会输出到终端</span></span><br><span class=\"line\">    rm app</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(BUILD_DOCKER_IMAGE)</span>,1)</span><br><span class=\"line\">    @docker rmi recommend_photo</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dockerfile不能访问父级目录\"><a href=\"#Dockerfile不能访问父级目录\" class=\"headerlink\" title=\"Dockerfile不能访问父级目录\"></a>Dockerfile不能访问父级目录</h1><p>项目汇中我使用Dockerfile作为构架docker镜像的基础。通过<code>docker build -t image_name .</code>可以将内容打包成本地的docker镜像。但是鉴于我现有的项目目录结构使得<code>COPY</code>无法找到对应的文件，在查阅<code>docker build</code>命令后，发现可以通过<code>-f</code>选项来执行相关目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我的目录结构</span><br><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── cmd</span><br><span class=\"line\">│   └── main.go</span><br><span class=\"line\">├── conf</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── deploy</span><br><span class=\"line\">│   └── Dockerfile</span><br><span class=\"line\">├── http</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── model</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── makefile</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">├── go.sum</span><br><span class=\"line\">├── config.yaml</span><br><span class=\"line\">├── sample.config.yaml</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决Dockerbuild目录可见性问题（使用-f-选项）\"><a href=\"#解决Dockerbuild目录可见性问题（使用-f-选项）\" class=\"headerlink\" title=\"解决Dockerbuild目录可见性问题（使用 -f 选项）\"></a>解决Dockerbuild目录可见性问题（使用 -f 选项）</h2><p>docker与dockerfile的关系这里不再阐述。这只单独介绍docker build<code>-f</code>选项的使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  project git:(dev) docker build -h   </span><br><span class=\"line\">Flag shorthand -h has been deprecated, please use --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class=\"line\"></span><br><span class=\"line\">Build an image from a Dockerfile</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class=\"line\">      --build-arg list          Set build-time variables</span><br><span class=\"line\">      --cache-from strings      Images to consider as cache sources</span><br><span class=\"line\">      --disable-content-trust   Skip image verification (default true)</span><br><span class=\"line\">  -f, --file string             Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>平时使用docker build一般是在根目录存在Dockerfile，构建的时候Dockerfile会在当前目录寻找需要的文件，但是在我的目录结构中，Dockerfile被放到了deploy目录下，导致我在根目录执行docker build会找不到file，但是cd到deploy目录里又会导致Dockerfile找不到根目录的文件。所以这里<code>-f</code>选项就可以使用了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t name:tag  -f deploy/Dockerfile ./deploy</span><br></pre></td></tr></table></figure>\n<p><code>-f</code>选项指定了Dockerfile所在的目录，最后的<code>./deploy</code>是docker构建使用的根目录</p>\n<h2 id=\"向Dockerfile中传递编译参数\"><a href=\"#向Dockerfile中传递编译参数\" class=\"headerlink\" title=\"向Dockerfile中传递编译参数\"></a>向Dockerfile中传递编译参数</h2><p>通过<code>-build-arg &#123;ARG_NAME&#125;=&#123;value&#125;</code>可以传递参数，那么在dockerfile中，通过<code>arg</code> 定义的变量可以接收到传递到参数<code>ARG ARG_NAME=hello</code></p>\n<h1 id=\"使用Alpine作为基础来制作我的容器镜像\"><a href=\"#使用Alpine作为基础来制作我的容器镜像\" class=\"headerlink\" title=\"使用Alpine作为基础来制作我的容器镜像\"></a>使用Alpine作为基础来制作我的容器镜像</h1><h2 id=\"Docker打包出的镜像超过1G让我不能接受\"><a href=\"#Docker打包出的镜像超过1G让我不能接受\" class=\"headerlink\" title=\"Docker打包出的镜像超过1G让我不能接受\"></a>Docker打包出的镜像超过1G让我不能接受</h2><p>在项目刚写完的时候，我使用golang官网的docker镜像作为基础来构建我自己的镜像。这样做可以不用担心环境问题，打包golang构建docker一气呵成固然方便，但当我看到我的镜像有1.2G大的时候猛打了一个寒颤～这是在超出我的所料。<br>作为追求精简的程序员，这种情况不允许发生在我的项目里，于是便有了下面的内容</p>\n<h2 id=\"Alpine镜像是什么\"><a href=\"#Alpine镜像是什么\" class=\"headerlink\" title=\"Alpine镜像是什么\"></a>Alpine镜像是什么</h2><blockquote>\n<p>Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musl libc(注意这里，是个坑) 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 <a href=\"https://pkgs.alpinelinux.org/packages\">https://pkgs.alpinelinux.org/packages</a> 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。</p>\n</blockquote>\n<h2 id=\"将golang编译与docker打包拆分\"><a href=\"#将golang编译与docker打包拆分\" class=\"headerlink\" title=\"将golang编译与docker打包拆分\"></a>将golang编译与docker打包拆分</h2><p>为了尽可能的减小docker镜像的体积，我采用了只将golang可执行文件与config文件打包进镜像的方案（大家可以制作自己的打包服务器或者直接使用各种CI&#x2F;CD流水线来帮助构建镜像）。在这之后，我的小而美的docker镜像中只存在两个必要文件<code>app(可执行文件) &amp; config.yaml</code>。而我的镜像也变成了精简的49MB</p>\n<h2 id=\"制作镜像时遇到的问题\"><a href=\"#制作镜像时遇到的问题\" class=\"headerlink\" title=\"制作镜像时遇到的问题\"></a>制作镜像时遇到的问题</h2><p>可是当我使用镜像构建容器的时候，却总是提示</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  project git:(dev) docker run -it --rm 351b4d544b4e</span><br><span class=\"line\">exec /app/app: no such file or directory</span><br></pre></td></tr></table></figure>\n<p>开始很没头绪，因为使用了阿里云的流水线服务所以我还特意发了工单去询问（这显得我很白痴）。后来我通过<code>docker save imageID &gt; filename.tar</code>的方式将镜像下载到本地，然后解压去查找对应的文件，发现<code>/app/app</code>可执行文件就好好的躺在它该在的目录。这时候我才把目光转向了我的基础镜像。于是发现并解决了如下问题(部分内容引用自<a href=\"https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html\">使用Alpine作为基础镜像时可能会遇到的常见问题的解决方法</a>)：</p>\n<h2 id=\"镜像中存在可执行文件但是报错no-such-file-or-directory\"><a href=\"#镜像中存在可执行文件但是报错no-such-file-or-directory\" class=\"headerlink\" title=\"镜像中存在可执行文件但是报错no such file or directory\"></a>镜像中存在可执行文件但是报错no such file or directory</h2><p>由于golang构建与docker基于alpine打包分开<br>我的二进制文件是使用动态链接方式编译了一个使用了GLIBC库的程序生成的，但是alpne镜像中没有GLIBC库而是用的MUSL LIBC库，这样就会导致该二进制文件无法被执行。<br>解决方案一般有两种：</p>\n<blockquote>\n<ul>\n<li>改为静态编译</li>\n<li>如果要使用动态链接函数编译的话，不要依赖GLIBC（比如编译Go程序的时候指定CGO_ENABLED&#x3D;0 ）或者在alpine中编译一个依赖MUSL LIBC的版本</li>\n</ul>\n</blockquote>\n<p>追求精简的我选择了第一种<a href=\"https://juejin.cn/post/7053450610386468894\">静态编译</a><br>同时也实测简单的指定<code>CGO_ENABLED=0</code>并不完全解决问题</p>\n<h2 id=\"alpine时区问题\"><a href=\"#alpine时区问题\" class=\"headerlink\" title=\"alpine时区问题\"></a>alpine时区问题</h2><p>有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">Init mysql error: unknown time zone Asia/Shanghai</span><br></pre></td></tr></table></figure>\n<p>常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误。<br>所以需要我们在构建镜像是安装自己需要的时区文件,之后就不会存在时区问题了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine:latest</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\"></span><br><span class=\"line\">ENV TZ Asia/Shanghai</span><br><span class=\"line\">RUN apk update &amp;&amp; apk add tzdata</span><br><span class=\"line\">RUN cp /usr/share/zoneinfo/$&#123;TZ&#125; /etc/localtime \\</span><br><span class=\"line\">    &amp;&amp; echo $&#123;TZ&#125; &gt; /etc/timezone</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>以上，解决了我这次项目中的问题。</p>\n<p>本来还想写一下关于golang静态编译的问题，但发现我还没有真正搞明白，所以先贴个链接吧，以后再写：<a href=\"https://juejin.cn/post/7053450610386468894\">https://juejin.cn/post/7053450610386468894</a></p>\n"},{"title":"Golang GUI开发总结","comments":1,"banner_img_height":30,"date":"2022-11-03T05:53:12.000Z","_content":"  - [govcl](https://github.com/ying32/govcl)\n  - [fyne](https://github.com/fyne-io/fyne)\n  - [wails](https://github.com/wailsapp/wails)\n  - [walk](https://github.com/lxn/walk)\n  - [wxwidgets](https://www.wxwidgets.org/)\n  - [webview](https://github.com/webview/webview)","source":"_posts/Golang-GUI开发总结.md","raw":"---\ntitle: Golang GUI开发总结\ncomments: true\nbanner_img_height: 30\ndate: 2022-11-03 13:53:12\ncategories:\n- Golang\ntags:\n- Golang\n- GUI\n---\n  - [govcl](https://github.com/ying32/govcl)\n  - [fyne](https://github.com/fyne-io/fyne)\n  - [wails](https://github.com/wailsapp/wails)\n  - [walk](https://github.com/lxn/walk)\n  - [wxwidgets](https://www.wxwidgets.org/)\n  - [webview](https://github.com/webview/webview)","slug":"Golang-GUI开发总结","published":1,"updated":"2023-11-13T06:50:53.657Z","_id":"clowjpr49000likfyen9z5ymd","layout":"post","photos":[],"content":"<ul>\n<li><a href=\"https://github.com/ying32/govcl\">govcl</a></li>\n<li><a href=\"https://github.com/fyne-io/fyne\">fyne</a></li>\n<li><a href=\"https://github.com/wailsapp/wails\">wails</a></li>\n<li><a href=\"https://github.com/lxn/walk\">walk</a></li>\n<li><a href=\"https://www.wxwidgets.org/\">wxwidgets</a></li>\n<li><a href=\"https://github.com/webview/webview\">webview</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/ying32/govcl\">govcl</a></li>\n<li><a href=\"https://github.com/fyne-io/fyne\">fyne</a></li>\n<li><a href=\"https://github.com/wailsapp/wails\">wails</a></li>\n<li><a href=\"https://github.com/lxn/walk\">walk</a></li>\n<li><a href=\"https://www.wxwidgets.org/\">wxwidgets</a></li>\n<li><a href=\"https://github.com/webview/webview\">webview</a></li>\n</ul>\n"},{"title":"Golang构建桌面程序之webview","comments":1,"banner_img_height":30,"date":"2022-11-03T04:19:36.000Z","_content":"\n## 序\n最近接到的任务是开发一个可以在mac和windows上运行的程序，作为一个golang程序员首先想到的自然是golang。跨平台编译运行也让他可以做这件事。结合前面我了解到的一些框架（[govcl](https://github.com/ying32/govcl),[fyne](https://github.com/fyne-io/fyne),[wails](https://github.com/wailsapp/wails),[walk](https://github.com/lxn/walk),[wxwidgets](https://www.wxwidgets.org/)），考虑学习的时间成本我本来是想用[fyne](https://github.com/fyne-io/fyne)来做。直到后来我找到了这个能更快完成需求的包[webview](https://github.com/webview/webview)。所以今天主要来介绍[webview](https://github.com/webview/webview)这个可以跨平台生成可执行文件的框架。\n\n## Golang 的 webview package","source":"_posts/Golang构建桌面程序之webview.md","raw":"---\ntitle: Golang构建桌面程序之webview\ncomments: true\nbanner_img_height: 30\ndate: 2022-11-03 12:19:36\ncategories:\n- Golang\ntags:\n- Golang\n- webview\n- embed\n- vue\n- gin\n- GUI\n---\n\n## 序\n最近接到的任务是开发一个可以在mac和windows上运行的程序，作为一个golang程序员首先想到的自然是golang。跨平台编译运行也让他可以做这件事。结合前面我了解到的一些框架（[govcl](https://github.com/ying32/govcl),[fyne](https://github.com/fyne-io/fyne),[wails](https://github.com/wailsapp/wails),[walk](https://github.com/lxn/walk),[wxwidgets](https://www.wxwidgets.org/)），考虑学习的时间成本我本来是想用[fyne](https://github.com/fyne-io/fyne)来做。直到后来我找到了这个能更快完成需求的包[webview](https://github.com/webview/webview)。所以今天主要来介绍[webview](https://github.com/webview/webview)这个可以跨平台生成可执行文件的框架。\n\n## Golang 的 webview package","slug":"Golang构建桌面程序之webview","published":1,"updated":"2023-11-13T06:50:53.661Z","_id":"clowjpr4c000qikfy3e4idllr","layout":"post","photos":[],"content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近接到的任务是开发一个可以在mac和windows上运行的程序，作为一个golang程序员首先想到的自然是golang。跨平台编译运行也让他可以做这件事。结合前面我了解到的一些框架（<a href=\"https://github.com/ying32/govcl\">govcl</a>,<a href=\"https://github.com/fyne-io/fyne\">fyne</a>,<a href=\"https://github.com/wailsapp/wails\">wails</a>,<a href=\"https://github.com/lxn/walk\">walk</a>,<a href=\"https://www.wxwidgets.org/\">wxwidgets</a>），考虑学习的时间成本我本来是想用<a href=\"https://github.com/fyne-io/fyne\">fyne</a>来做。直到后来我找到了这个能更快完成需求的包<a href=\"https://github.com/webview/webview\">webview</a>。所以今天主要来介绍<a href=\"https://github.com/webview/webview\">webview</a>这个可以跨平台生成可执行文件的框架。</p>\n<h2 id=\"Golang-的-webview-package\"><a href=\"#Golang-的-webview-package\" class=\"headerlink\" title=\"Golang 的 webview package\"></a>Golang 的 webview package</h2>","excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近接到的任务是开发一个可以在mac和windows上运行的程序，作为一个golang程序员首先想到的自然是golang。跨平台编译运行也让他可以做这件事。结合前面我了解到的一些框架（<a href=\"https://github.com/ying32/govcl\">govcl</a>,<a href=\"https://github.com/fyne-io/fyne\">fyne</a>,<a href=\"https://github.com/wailsapp/wails\">wails</a>,<a href=\"https://github.com/lxn/walk\">walk</a>,<a href=\"https://www.wxwidgets.org/\">wxwidgets</a>），考虑学习的时间成本我本来是想用<a href=\"https://github.com/fyne-io/fyne\">fyne</a>来做。直到后来我找到了这个能更快完成需求的包<a href=\"https://github.com/webview/webview\">webview</a>。所以今天主要来介绍<a href=\"https://github.com/webview/webview\">webview</a>这个可以跨平台生成可执行文件的框架。</p>\n<h2 id=\"Golang-的-webview-package\"><a href=\"#Golang-的-webview-package\" class=\"headerlink\" title=\"Golang 的 webview package\"></a>Golang 的 webview package</h2>"},{"title":"NFC基础知识与读写","comments":1,"banner_img_height":30,"date":"2022-11-18T08:59:43.000Z","_content":"## 序\n最近的项目需求中，需要使用NFC芯片来保存一些类似于url的信息并通过iOS或Android手机能正常获取到相关信息，所以针对NFC相关技术与特点进行了学习和总结。我会把我看过教程链接也同步贴到文章中。因为手上只有M1卡，所以下面的主要内容也围绕M1卡来进行\n## 什么是NFC\n近场通信（英语：Near-field communication，NFC），又称近距离无线通信、近距离通信，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。NFC，如同过去的电子票券智能卡一般，将允许移动支付取代或支持这类系统。NFC应用于社交网络，分享联系方式、照片、视频或文件。具备 NFC 功能的设备可以充当电子身份证和钥匙卡。NFC 提供了设置简便的低速连接，也可用于引导能力更强的无线连接。\n\n近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit/秒、212 Kbit/秒或者424 Kbit/秒三种。目前近场通信已通过成为ISO/IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。NFC采用主动和被动两种读取模式。\n\n每一个完整的NFC设备可以用三种模式工作：\n\n- 卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备（如手机）没电也可以工作。NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全组件（Security Element, SE）之NFC芯片或通过软件实现主机卡模拟(Host Card Emulation，HCE)。\n- 读卡器模式（Reader/Writer mode）：作为非接触读卡器使用，比如从海报或者展览信息电子标签上读取相关信息。\n- 点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。因此通过NFC，多个设备如数位相机、PDA、计算机和手机之间都可以交换资料或者服务。\n\n> [维基百科-近场通信](https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A)\n> [百度-NFC](https://baike.baidu.com/item/%E8%BF%91%E5%9C%BA%E9%80%9A%E4%BF%A1/9741433?fromtitle=nfc&fromid=5684&fr=aladdin)\n\n## 各种NFC卡的区别\n| 卡       | 功能描述                                                                                                                |\n| :------- | :---------------------------------------------------------------------------------------------------------------------- |\n| 普通IC卡 | 0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。 |\n| UID 卡   | 普通复制卡，可以重复擦写所有扇区，主要应用在IC卡复制上，遇到带有防火墙的读卡器就会失效。                                |\n| CUID 卡  | 可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。                                       |\n| FUID 卡  | 不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。          |\n| UFUID 卡 | 高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。                  |\n>[知乎-司小凯-UID卡、IC卡、ID卡、CUID 卡、FUID 卡、UFUID 卡 的区别](https://zhuanlan.zhihu.com/p/351266514)\n## NFC标签类型\n目前iOS系统并没有开放过多的NFC权限，所以这里讨论通过Android系统操作NFC标签，以下是Android系统操作NFC标签支持的标签技术类型\n| Class            | Description                                                                            |\n| :--------------- | :------------------------------------------------------------------------------------- |\n| TagTechnology    | 这是所有标签技术类都必须实现的接口。                                                   |\n| NfcA             | 提供对 NFC-A (ISO 14443-3A) 属性和 I/O 操作的访问权限。                                |\n| NfcB             | 提供对 NFC-B (ISO 14443-3B) 属性和 I/O 操作的访问权限。                                |\n| NfcF             | 提供对 NFC-F (JIS 6319-4) 属性和 I/O 操作的访问权限。                                  |\n| NfcV             | 提供对 NFC-V (ISO 15693) 属性和 I/O 操作的访问权限。                                   |\n| IsoDep           | 提供对 ISO-DEP (ISO 14443-4) 属性和 I/O 操作的访问权限。                               |\n| Ndef             | 提供对 NDEF 格式的 NFC 标签上的 NDEF 数据和操作的访问权限。                            |\n| NdefFormatable   | 为可设置为 NDEF 格式的标签提供格式化操作。                                             |\n| MifareClassic    | 提供对 MIFARE Classic 属性和 I/O 操作的访问权限（如果此 Android 设备支持 MIFARE）。    |\n| MifareUltralight | 提供对 MIFARE Ultralight 属性和 I/O 操作的访问权限（如果此 Android 设备支持 MIFARE）。 |\n>[Android开发文档-高级NFC概览](https://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc?hl=zh_cn)\n\n## NDEF数据格式\n这里讲的很详细：\n>[NDEF技术规范](http://article.iotxfd.cn/RFID/NDEF)\n\n## Mifare Classic标签（M1卡）\nNFC 有很多协议，其中 MIFARE Classic 基于 ISO 14443-3 Type A 标准，里面有一些 MIFARE 的命令。通过这些命令，就可以控制 MIFARE Classic 卡的内容。[MIFARE Classic EV1 4K S70](https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf)\n>[杰哥的{运维,编程,调板子}小笔记-MIFARE Classic 上配置 NDEF](https://jia.je/hardware/2020/05/10/mifare-classic-ndef/)\n### Sector&Block 标签的内存布局\n在 MIFARE Classic 中，有 Sector 和 Block 的概念，每个 Sector 有若干个 Block，其中最后一个 Block 是特殊的（称为 Sector Trailer），保存了这个 Sector 的一些信息：Key A、Access Bits、GPB 和 Key B。对于 Classic 4K，首先是 32 个有 4 blocks 的 sector，（M1卡）整体的内存布局大概是：\n``` shell\nSector 0:\n\tBlock 0 (出厂时写入了标签ID，厂商信息等，不可修改)\n\tBlock 1\n\tBlock 2\n\tBlock 3(Sector Trailer)\nSector 1:\n\tBlock 4\n\tBlock 5\n\tBlock 6\n\tBlock 7(Sector Trailer)\n...\nSector 15:\n\tBlock 60\n\tBlock 61\n\tBlock 62\n\tBlock 63(Sector Trailer)\n```\nSector Trailer 的布局如下：\n| Key A | Access Bits | GPB   | Key B |\n| :---- | :---------- | :---- | :---- |\n| 6字节 | 3字节       | 1字节 | 6字节 |\n### A、B密钥与控制位\n其中Access Bits（控制位）决定了密钥A、B对每个Block的读写权限，关于控制位详解参见：\n>[CSDN-小流氓哥哥-IC卡 M1卡 各个扇区 控制块 密码 详解](https://blog.csdn.net/hanlinhe111/article/details/121100198)\n### 读取写入等操作命令\n- 认证：\n    一条认证指令：0x60 0x05 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF（0x60：使用密钥A[0x61：使用密钥B]，0x05：sector1-block1就是指从0开始编号的第n个块，后面6个16进制数即是密钥A）\n- 读取：\n    一条读取指令：0x30 0x05 （0x30：读取命令，0x05：sector1-block1就是指从0开始编号的第n个块）\n    这里是要读取扇区1块0的内容\n- 写入：\n    一条写入指令：0xA0 0x06 0x64 0x6C 0x2F 0x62 0x75 0x73 0x69 0x6E 0x65 0x73 0x73 0x2F 0x3F 0x74 0x3D 0x6E（0xA0：写入命令，0x06：sector1-block2就是指从0开始编号的第n个块，后面为16个16进制数组成的要写入的内容）\n    这里要写入扇区1块1的内容为：646C2F627573696E6573732F3F743D6E\n- 内容格式：\n    文字内容需要将文字对应的Ascii码值转化为16进制\n\n借用微信的能力使用小程序对NFC标签进行读写的时候需要将命令内容转化为二进制内容：\n>[微信开放社区提问的评论内容](https://developers.weixin.qq.com/community/develop/doc/0004e61e77ccb8187a5b325415b400)\n### 认证与读写流程\n针对扇区的读取与写入操作都需要使用密钥进行验证，验证成功后就可以执行相关的读写命令\n\n## NDEF on Mifare Classic\nNDEF 只定义了数据格式，但为了实际使用，还得看具体情况。就好像文件内容保存在硬盘上的时候，并不是直接保存，而是通过文件系统，人为定义一个路径，这样大家才知道要从 /etc/shadow 文件去读 Linux 的用户密码信息，NDEF 也需要人为定义一些规则，再作为数据存放在智能卡里的某个地方，这样大家去读取 metadata，发现上 NDEF Tag，然后才会去解析 NDEF 信息。\n\n有些时候，这个定义很简单，比如直接把 NDEF 数据放在某个 block 里面；有的时候又很复杂，因为可能同时存在很多应用，NDEF 只是其中的一种，所以要有一种类似目录的东西去索引 NDEF“文件”。\n\nMIFARE Classic 上采用的方法上，在特定的 Sector（比如 Sector 0）放一些元数据，元数据里注明了其他的 Sector（从 1 开始的其它 sector）分别用于什么用途，然后 NDEF 是其中一种用途。这个结构叫做 [MIFARE Application Directory](https://www.nxp.com.cn/docs/en/application-note/AN10787.pdf)。具体来说，在 MIFARE Classic 里面，它规定 Block 1 和 Block 2 的内容如下：\n| 0-1        | 2-3  | 4-5  | 6-7  | 8-9  | 10-11 | 12-13 | 14-15 |\n| :--------- | :--- | :--- | :--- | :--- | :---- | :---- | :---- |\n| Info & CRC | AID  | AID  | AID  | AID  | AID   | AID   | AID   |\n| AID        | AID  | AID  | AID  | AID  | AID   | AID   | AID   |\n\n第一个字节是 CRC 8，它的定义可以在这里的 [CRC-8/MIFARE-MAD](https://reveng.sourceforge.io/crc-catalogue/1-15.htm) 里找到：初始值 0xC7，多项式上 0x1D。参与 CRC 计算的是按顺序从第二个字节开始的 31 个字节。\n\n第二个字节是 Info Byte，用处不大，见 MAD 的文档。\n\n之后每两个字节对应一个 Sector 的 AID（Application ID），比如 Block 1 的 2-3 字节对应 Sector 1 的 AID，Block 1 的 4-5 字节对应 Sector 2 的 AID，最后 Block 2 的 14-15 字节对应 Sector 15 的 AID。NDEF 的 AID 就是 0x03 0xE1。当软件发现这里的 AID 是 0x03E1 的时候，它就会去相应的 Sector 去读取 NDEF 信息。\n\n省流助手：[0x14 0x01]可以理解为标记扇区0为索引，[0x03 0xE1]可以理解为标记扇区为NDEF消息储存空间。所以一个将NDEF信息记录在Mifare Classic标签上的数据形式大概类似这样：\n``` shell\nSector0\n    Block0 E7 CA C1 B3 5F 08 04 00 02 78 B1 F6 C9 6F FA 1D（芯片ID与厂商信息）\n    Block1 14 01 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1（相当于所有扇区的类型索引）\n    Block2 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 14 01（相当于所有扇区的类型索引）\n    Block3 A0 A1 A2 A3 A4 A5 78 77 88 C1 B0 B1 B2 B3 B4 B5（密钥A：A0A1A2A3A4A5 控制位：787788[表示扇区0密钥A只读，密钥B读写] C1[C1实际上不参与控制，可以用来替换成其他的内容保存用户数据] 密钥B：B0B1B2B3B4B5）\nSector1\n    Block0 48 45 4C 4C 4F 59 4F 52 4C 44 00 00 00 00 00 00（自定义的数据内容，翻译：HELLOWORLD）\n    Block1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）\n    Block2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）\n    Block3 FF FF FF FF FF FF 78 77 88 C1 FF FF FF FF FF FF（密钥与控制位）\nSector2\n    Block0\n    Block1\n    Block2\n    Block3\n......\n\nSector16\n    Block0\n    Block1\n    Block2\n    Block3\n```\n## 通过微信小程序读写标签\n以上内容，主要是基础知识的补充，下面是真正的干货demo\n\n[这里是我开源的用来对MifareClassic芯片（M1芯片）进行读写的项目](https://github.com/MangK/NFCTools-MiniProgram)\n\n## The end\n>再次感谢以上文章引用中提到的博主与作者！！！","source":"_posts/NFC基础知识与读写.md","raw":"---\ntitle: NFC基础知识与读写\ncomments: true\nbanner_img_height: 30\ndate: 2022-11-18 16:59:43\ncategories:\n- 小程序\ntags:\n- NFC\n- Ndef\n- MifareClassic\n---\n## 序\n最近的项目需求中，需要使用NFC芯片来保存一些类似于url的信息并通过iOS或Android手机能正常获取到相关信息，所以针对NFC相关技术与特点进行了学习和总结。我会把我看过教程链接也同步贴到文章中。因为手上只有M1卡，所以下面的主要内容也围绕M1卡来进行\n## 什么是NFC\n近场通信（英语：Near-field communication，NFC），又称近距离无线通信、近距离通信，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。NFC，如同过去的电子票券智能卡一般，将允许移动支付取代或支持这类系统。NFC应用于社交网络，分享联系方式、照片、视频或文件。具备 NFC 功能的设备可以充当电子身份证和钥匙卡。NFC 提供了设置简便的低速连接，也可用于引导能力更强的无线连接。\n\n近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit/秒、212 Kbit/秒或者424 Kbit/秒三种。目前近场通信已通过成为ISO/IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。NFC采用主动和被动两种读取模式。\n\n每一个完整的NFC设备可以用三种模式工作：\n\n- 卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备（如手机）没电也可以工作。NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全组件（Security Element, SE）之NFC芯片或通过软件实现主机卡模拟(Host Card Emulation，HCE)。\n- 读卡器模式（Reader/Writer mode）：作为非接触读卡器使用，比如从海报或者展览信息电子标签上读取相关信息。\n- 点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。因此通过NFC，多个设备如数位相机、PDA、计算机和手机之间都可以交换资料或者服务。\n\n> [维基百科-近场通信](https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A)\n> [百度-NFC](https://baike.baidu.com/item/%E8%BF%91%E5%9C%BA%E9%80%9A%E4%BF%A1/9741433?fromtitle=nfc&fromid=5684&fr=aladdin)\n\n## 各种NFC卡的区别\n| 卡       | 功能描述                                                                                                                |\n| :------- | :---------------------------------------------------------------------------------------------------------------------- |\n| 普通IC卡 | 0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。 |\n| UID 卡   | 普通复制卡，可以重复擦写所有扇区，主要应用在IC卡复制上，遇到带有防火墙的读卡器就会失效。                                |\n| CUID 卡  | 可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。                                       |\n| FUID 卡  | 不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。          |\n| UFUID 卡 | 高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。                  |\n>[知乎-司小凯-UID卡、IC卡、ID卡、CUID 卡、FUID 卡、UFUID 卡 的区别](https://zhuanlan.zhihu.com/p/351266514)\n## NFC标签类型\n目前iOS系统并没有开放过多的NFC权限，所以这里讨论通过Android系统操作NFC标签，以下是Android系统操作NFC标签支持的标签技术类型\n| Class            | Description                                                                            |\n| :--------------- | :------------------------------------------------------------------------------------- |\n| TagTechnology    | 这是所有标签技术类都必须实现的接口。                                                   |\n| NfcA             | 提供对 NFC-A (ISO 14443-3A) 属性和 I/O 操作的访问权限。                                |\n| NfcB             | 提供对 NFC-B (ISO 14443-3B) 属性和 I/O 操作的访问权限。                                |\n| NfcF             | 提供对 NFC-F (JIS 6319-4) 属性和 I/O 操作的访问权限。                                  |\n| NfcV             | 提供对 NFC-V (ISO 15693) 属性和 I/O 操作的访问权限。                                   |\n| IsoDep           | 提供对 ISO-DEP (ISO 14443-4) 属性和 I/O 操作的访问权限。                               |\n| Ndef             | 提供对 NDEF 格式的 NFC 标签上的 NDEF 数据和操作的访问权限。                            |\n| NdefFormatable   | 为可设置为 NDEF 格式的标签提供格式化操作。                                             |\n| MifareClassic    | 提供对 MIFARE Classic 属性和 I/O 操作的访问权限（如果此 Android 设备支持 MIFARE）。    |\n| MifareUltralight | 提供对 MIFARE Ultralight 属性和 I/O 操作的访问权限（如果此 Android 设备支持 MIFARE）。 |\n>[Android开发文档-高级NFC概览](https://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc?hl=zh_cn)\n\n## NDEF数据格式\n这里讲的很详细：\n>[NDEF技术规范](http://article.iotxfd.cn/RFID/NDEF)\n\n## Mifare Classic标签（M1卡）\nNFC 有很多协议，其中 MIFARE Classic 基于 ISO 14443-3 Type A 标准，里面有一些 MIFARE 的命令。通过这些命令，就可以控制 MIFARE Classic 卡的内容。[MIFARE Classic EV1 4K S70](https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf)\n>[杰哥的{运维,编程,调板子}小笔记-MIFARE Classic 上配置 NDEF](https://jia.je/hardware/2020/05/10/mifare-classic-ndef/)\n### Sector&Block 标签的内存布局\n在 MIFARE Classic 中，有 Sector 和 Block 的概念，每个 Sector 有若干个 Block，其中最后一个 Block 是特殊的（称为 Sector Trailer），保存了这个 Sector 的一些信息：Key A、Access Bits、GPB 和 Key B。对于 Classic 4K，首先是 32 个有 4 blocks 的 sector，（M1卡）整体的内存布局大概是：\n``` shell\nSector 0:\n\tBlock 0 (出厂时写入了标签ID，厂商信息等，不可修改)\n\tBlock 1\n\tBlock 2\n\tBlock 3(Sector Trailer)\nSector 1:\n\tBlock 4\n\tBlock 5\n\tBlock 6\n\tBlock 7(Sector Trailer)\n...\nSector 15:\n\tBlock 60\n\tBlock 61\n\tBlock 62\n\tBlock 63(Sector Trailer)\n```\nSector Trailer 的布局如下：\n| Key A | Access Bits | GPB   | Key B |\n| :---- | :---------- | :---- | :---- |\n| 6字节 | 3字节       | 1字节 | 6字节 |\n### A、B密钥与控制位\n其中Access Bits（控制位）决定了密钥A、B对每个Block的读写权限，关于控制位详解参见：\n>[CSDN-小流氓哥哥-IC卡 M1卡 各个扇区 控制块 密码 详解](https://blog.csdn.net/hanlinhe111/article/details/121100198)\n### 读取写入等操作命令\n- 认证：\n    一条认证指令：0x60 0x05 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF（0x60：使用密钥A[0x61：使用密钥B]，0x05：sector1-block1就是指从0开始编号的第n个块，后面6个16进制数即是密钥A）\n- 读取：\n    一条读取指令：0x30 0x05 （0x30：读取命令，0x05：sector1-block1就是指从0开始编号的第n个块）\n    这里是要读取扇区1块0的内容\n- 写入：\n    一条写入指令：0xA0 0x06 0x64 0x6C 0x2F 0x62 0x75 0x73 0x69 0x6E 0x65 0x73 0x73 0x2F 0x3F 0x74 0x3D 0x6E（0xA0：写入命令，0x06：sector1-block2就是指从0开始编号的第n个块，后面为16个16进制数组成的要写入的内容）\n    这里要写入扇区1块1的内容为：646C2F627573696E6573732F3F743D6E\n- 内容格式：\n    文字内容需要将文字对应的Ascii码值转化为16进制\n\n借用微信的能力使用小程序对NFC标签进行读写的时候需要将命令内容转化为二进制内容：\n>[微信开放社区提问的评论内容](https://developers.weixin.qq.com/community/develop/doc/0004e61e77ccb8187a5b325415b400)\n### 认证与读写流程\n针对扇区的读取与写入操作都需要使用密钥进行验证，验证成功后就可以执行相关的读写命令\n\n## NDEF on Mifare Classic\nNDEF 只定义了数据格式，但为了实际使用，还得看具体情况。就好像文件内容保存在硬盘上的时候，并不是直接保存，而是通过文件系统，人为定义一个路径，这样大家才知道要从 /etc/shadow 文件去读 Linux 的用户密码信息，NDEF 也需要人为定义一些规则，再作为数据存放在智能卡里的某个地方，这样大家去读取 metadata，发现上 NDEF Tag，然后才会去解析 NDEF 信息。\n\n有些时候，这个定义很简单，比如直接把 NDEF 数据放在某个 block 里面；有的时候又很复杂，因为可能同时存在很多应用，NDEF 只是其中的一种，所以要有一种类似目录的东西去索引 NDEF“文件”。\n\nMIFARE Classic 上采用的方法上，在特定的 Sector（比如 Sector 0）放一些元数据，元数据里注明了其他的 Sector（从 1 开始的其它 sector）分别用于什么用途，然后 NDEF 是其中一种用途。这个结构叫做 [MIFARE Application Directory](https://www.nxp.com.cn/docs/en/application-note/AN10787.pdf)。具体来说，在 MIFARE Classic 里面，它规定 Block 1 和 Block 2 的内容如下：\n| 0-1        | 2-3  | 4-5  | 6-7  | 8-9  | 10-11 | 12-13 | 14-15 |\n| :--------- | :--- | :--- | :--- | :--- | :---- | :---- | :---- |\n| Info & CRC | AID  | AID  | AID  | AID  | AID   | AID   | AID   |\n| AID        | AID  | AID  | AID  | AID  | AID   | AID   | AID   |\n\n第一个字节是 CRC 8，它的定义可以在这里的 [CRC-8/MIFARE-MAD](https://reveng.sourceforge.io/crc-catalogue/1-15.htm) 里找到：初始值 0xC7，多项式上 0x1D。参与 CRC 计算的是按顺序从第二个字节开始的 31 个字节。\n\n第二个字节是 Info Byte，用处不大，见 MAD 的文档。\n\n之后每两个字节对应一个 Sector 的 AID（Application ID），比如 Block 1 的 2-3 字节对应 Sector 1 的 AID，Block 1 的 4-5 字节对应 Sector 2 的 AID，最后 Block 2 的 14-15 字节对应 Sector 15 的 AID。NDEF 的 AID 就是 0x03 0xE1。当软件发现这里的 AID 是 0x03E1 的时候，它就会去相应的 Sector 去读取 NDEF 信息。\n\n省流助手：[0x14 0x01]可以理解为标记扇区0为索引，[0x03 0xE1]可以理解为标记扇区为NDEF消息储存空间。所以一个将NDEF信息记录在Mifare Classic标签上的数据形式大概类似这样：\n``` shell\nSector0\n    Block0 E7 CA C1 B3 5F 08 04 00 02 78 B1 F6 C9 6F FA 1D（芯片ID与厂商信息）\n    Block1 14 01 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1（相当于所有扇区的类型索引）\n    Block2 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 14 01（相当于所有扇区的类型索引）\n    Block3 A0 A1 A2 A3 A4 A5 78 77 88 C1 B0 B1 B2 B3 B4 B5（密钥A：A0A1A2A3A4A5 控制位：787788[表示扇区0密钥A只读，密钥B读写] C1[C1实际上不参与控制，可以用来替换成其他的内容保存用户数据] 密钥B：B0B1B2B3B4B5）\nSector1\n    Block0 48 45 4C 4C 4F 59 4F 52 4C 44 00 00 00 00 00 00（自定义的数据内容，翻译：HELLOWORLD）\n    Block1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）\n    Block2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）\n    Block3 FF FF FF FF FF FF 78 77 88 C1 FF FF FF FF FF FF（密钥与控制位）\nSector2\n    Block0\n    Block1\n    Block2\n    Block3\n......\n\nSector16\n    Block0\n    Block1\n    Block2\n    Block3\n```\n## 通过微信小程序读写标签\n以上内容，主要是基础知识的补充，下面是真正的干货demo\n\n[这里是我开源的用来对MifareClassic芯片（M1芯片）进行读写的项目](https://github.com/MangK/NFCTools-MiniProgram)\n\n## The end\n>再次感谢以上文章引用中提到的博主与作者！！！","slug":"NFC基础知识与读写","published":1,"updated":"2023-11-13T06:50:53.667Z","_id":"clowjpr4c000rikfy77v9e08n","layout":"post","photos":[],"content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近的项目需求中，需要使用NFC芯片来保存一些类似于url的信息并通过iOS或Android手机能正常获取到相关信息，所以针对NFC相关技术与特点进行了学习和总结。我会把我看过教程链接也同步贴到文章中。因为手上只有M1卡，所以下面的主要内容也围绕M1卡来进行</p>\n<h2 id=\"什么是NFC\"><a href=\"#什么是NFC\" class=\"headerlink\" title=\"什么是NFC\"></a>什么是NFC</h2><p>近场通信（英语：Near-field communication，NFC），又称近距离无线通信、近距离通信，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。NFC，如同过去的电子票券智能卡一般，将允许移动支付取代或支持这类系统。NFC应用于社交网络，分享联系方式、照片、视频或文件。具备 NFC 功能的设备可以充当电子身份证和钥匙卡。NFC 提供了设置简便的低速连接，也可用于引导能力更强的无线连接。</p>\n<p>近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。目前近场通信已通过成为ISO&#x2F;IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。NFC采用主动和被动两种读取模式。</p>\n<p>每一个完整的NFC设备可以用三种模式工作：</p>\n<ul>\n<li>卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备（如手机）没电也可以工作。NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全组件（Security Element, SE）之NFC芯片或通过软件实现主机卡模拟(Host Card Emulation，HCE)。</li>\n<li>读卡器模式（Reader&#x2F;Writer mode）：作为非接触读卡器使用，比如从海报或者展览信息电子标签上读取相关信息。</li>\n<li>点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。因此通过NFC，多个设备如数位相机、PDA、计算机和手机之间都可以交换资料或者服务。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A\">维基百科-近场通信</a><br><a href=\"https://baike.baidu.com/item/%E8%BF%91%E5%9C%BA%E9%80%9A%E4%BF%A1/9741433?fromtitle=nfc&fromid=5684&fr=aladdin\">百度-NFC</a></p>\n</blockquote>\n<h2 id=\"各种NFC卡的区别\"><a href=\"#各种NFC卡的区别\" class=\"headerlink\" title=\"各种NFC卡的区别\"></a>各种NFC卡的区别</h2><table>\n<thead>\n<tr>\n<th align=\"left\">卡</th>\n<th align=\"left\">功能描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">普通IC卡</td>\n<td align=\"left\">0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。</td>\n</tr>\n<tr>\n<td align=\"left\">UID 卡</td>\n<td align=\"left\">普通复制卡，可以重复擦写所有扇区，主要应用在IC卡复制上，遇到带有防火墙的读卡器就会失效。</td>\n</tr>\n<tr>\n<td align=\"left\">CUID 卡</td>\n<td align=\"left\">可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。</td>\n</tr>\n<tr>\n<td align=\"left\">FUID 卡</td>\n<td align=\"left\">不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。</td>\n</tr>\n<tr>\n<td align=\"left\">UFUID 卡</td>\n<td align=\"left\">高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/351266514\">知乎-司小凯-UID卡、IC卡、ID卡、CUID 卡、FUID 卡、UFUID 卡 的区别</a></p>\n</blockquote>\n<h2 id=\"NFC标签类型\"><a href=\"#NFC标签类型\" class=\"headerlink\" title=\"NFC标签类型\"></a>NFC标签类型</h2><p>目前iOS系统并没有开放过多的NFC权限，所以这里讨论通过Android系统操作NFC标签，以下是Android系统操作NFC标签支持的标签技术类型</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Class</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">TagTechnology</td>\n<td align=\"left\">这是所有标签技术类都必须实现的接口。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcA</td>\n<td align=\"left\">提供对 NFC-A (ISO 14443-3A) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcB</td>\n<td align=\"left\">提供对 NFC-B (ISO 14443-3B) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcF</td>\n<td align=\"left\">提供对 NFC-F (JIS 6319-4) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcV</td>\n<td align=\"left\">提供对 NFC-V (ISO 15693) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">IsoDep</td>\n<td align=\"left\">提供对 ISO-DEP (ISO 14443-4) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">Ndef</td>\n<td align=\"left\">提供对 NDEF 格式的 NFC 标签上的 NDEF 数据和操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NdefFormatable</td>\n<td align=\"left\">为可设置为 NDEF 格式的标签提供格式化操作。</td>\n</tr>\n<tr>\n<td align=\"left\">MifareClassic</td>\n<td align=\"left\">提供对 MIFARE Classic 属性和 I&#x2F;O 操作的访问权限（如果此 Android 设备支持 MIFARE）。</td>\n</tr>\n<tr>\n<td align=\"left\">MifareUltralight</td>\n<td align=\"left\">提供对 MIFARE Ultralight 属性和 I&#x2F;O 操作的访问权限（如果此 Android 设备支持 MIFARE）。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><a href=\"https://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc?hl=zh_cn\">Android开发文档-高级NFC概览</a></p>\n</blockquote>\n<h2 id=\"NDEF数据格式\"><a href=\"#NDEF数据格式\" class=\"headerlink\" title=\"NDEF数据格式\"></a>NDEF数据格式</h2><p>这里讲的很详细：</p>\n<blockquote>\n<p><a href=\"http://article.iotxfd.cn/RFID/NDEF\">NDEF技术规范</a></p>\n</blockquote>\n<h2 id=\"Mifare-Classic标签（M1卡）\"><a href=\"#Mifare-Classic标签（M1卡）\" class=\"headerlink\" title=\"Mifare Classic标签（M1卡）\"></a>Mifare Classic标签（M1卡）</h2><p>NFC 有很多协议，其中 MIFARE Classic 基于 ISO 14443-3 Type A 标准，里面有一些 MIFARE 的命令。通过这些命令，就可以控制 MIFARE Classic 卡的内容。<a href=\"https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf\">MIFARE Classic EV1 4K S70</a></p>\n<blockquote>\n<p><a href=\"https://jia.je/hardware/2020/05/10/mifare-classic-ndef/\">杰哥的{运维,编程,调板子}小笔记-MIFARE Classic 上配置 NDEF</a></p>\n</blockquote>\n<h3 id=\"Sector-Block-标签的内存布局\"><a href=\"#Sector-Block-标签的内存布局\" class=\"headerlink\" title=\"Sector&amp;Block 标签的内存布局\"></a>Sector&amp;Block 标签的内存布局</h3><p>在 MIFARE Classic 中，有 Sector 和 Block 的概念，每个 Sector 有若干个 Block，其中最后一个 Block 是特殊的（称为 Sector Trailer），保存了这个 Sector 的一些信息：Key A、Access Bits、GPB 和 Key B。对于 Classic 4K，首先是 32 个有 4 blocks 的 sector，（M1卡）整体的内存布局大概是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sector 0:</span><br><span class=\"line\">\tBlock 0 (出厂时写入了标签ID，厂商信息等，不可修改)</span><br><span class=\"line\">\tBlock 1</span><br><span class=\"line\">\tBlock 2</span><br><span class=\"line\">\tBlock 3(Sector Trailer)</span><br><span class=\"line\">Sector 1:</span><br><span class=\"line\">\tBlock 4</span><br><span class=\"line\">\tBlock 5</span><br><span class=\"line\">\tBlock 6</span><br><span class=\"line\">\tBlock 7(Sector Trailer)</span><br><span class=\"line\">...</span><br><span class=\"line\">Sector 15:</span><br><span class=\"line\">\tBlock 60</span><br><span class=\"line\">\tBlock 61</span><br><span class=\"line\">\tBlock 62</span><br><span class=\"line\">\tBlock 63(Sector Trailer)</span><br></pre></td></tr></table></figure>\n<p>Sector Trailer 的布局如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Key A</th>\n<th align=\"left\">Access Bits</th>\n<th align=\"left\">GPB</th>\n<th align=\"left\">Key B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">6字节</td>\n<td align=\"left\">3字节</td>\n<td align=\"left\">1字节</td>\n<td align=\"left\">6字节</td>\n</tr>\n</tbody></table>\n<h3 id=\"A、B密钥与控制位\"><a href=\"#A、B密钥与控制位\" class=\"headerlink\" title=\"A、B密钥与控制位\"></a>A、B密钥与控制位</h3><p>其中Access Bits（控制位）决定了密钥A、B对每个Block的读写权限，关于控制位详解参见：</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/hanlinhe111/article/details/121100198\">CSDN-小流氓哥哥-IC卡 M1卡 各个扇区 控制块 密码 详解</a></p>\n</blockquote>\n<h3 id=\"读取写入等操作命令\"><a href=\"#读取写入等操作命令\" class=\"headerlink\" title=\"读取写入等操作命令\"></a>读取写入等操作命令</h3><ul>\n<li>认证：<br>  一条认证指令：0x60 0x05 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF（0x60：使用密钥A[0x61：使用密钥B]，0x05：sector1-block1就是指从0开始编号的第n个块，后面6个16进制数即是密钥A）</li>\n<li>读取：<br>  一条读取指令：0x30 0x05 （0x30：读取命令，0x05：sector1-block1就是指从0开始编号的第n个块）<br>  这里是要读取扇区1块0的内容</li>\n<li>写入：<br>  一条写入指令：0xA0 0x06 0x64 0x6C 0x2F 0x62 0x75 0x73 0x69 0x6E 0x65 0x73 0x73 0x2F 0x3F 0x74 0x3D 0x6E（0xA0：写入命令，0x06：sector1-block2就是指从0开始编号的第n个块，后面为16个16进制数组成的要写入的内容）<br>  这里要写入扇区1块1的内容为：646C2F627573696E6573732F3F743D6E</li>\n<li>内容格式：<br>  文字内容需要将文字对应的Ascii码值转化为16进制</li>\n</ul>\n<p>借用微信的能力使用小程序对NFC标签进行读写的时候需要将命令内容转化为二进制内容：</p>\n<blockquote>\n<p><a href=\"https://developers.weixin.qq.com/community/develop/doc/0004e61e77ccb8187a5b325415b400\">微信开放社区提问的评论内容</a></p>\n</blockquote>\n<h3 id=\"认证与读写流程\"><a href=\"#认证与读写流程\" class=\"headerlink\" title=\"认证与读写流程\"></a>认证与读写流程</h3><p>针对扇区的读取与写入操作都需要使用密钥进行验证，验证成功后就可以执行相关的读写命令</p>\n<h2 id=\"NDEF-on-Mifare-Classic\"><a href=\"#NDEF-on-Mifare-Classic\" class=\"headerlink\" title=\"NDEF on Mifare Classic\"></a>NDEF on Mifare Classic</h2><p>NDEF 只定义了数据格式，但为了实际使用，还得看具体情况。就好像文件内容保存在硬盘上的时候，并不是直接保存，而是通过文件系统，人为定义一个路径，这样大家才知道要从 &#x2F;etc&#x2F;shadow 文件去读 Linux 的用户密码信息，NDEF 也需要人为定义一些规则，再作为数据存放在智能卡里的某个地方，这样大家去读取 metadata，发现上 NDEF Tag，然后才会去解析 NDEF 信息。</p>\n<p>有些时候，这个定义很简单，比如直接把 NDEF 数据放在某个 block 里面；有的时候又很复杂，因为可能同时存在很多应用，NDEF 只是其中的一种，所以要有一种类似目录的东西去索引 NDEF“文件”。</p>\n<p>MIFARE Classic 上采用的方法上，在特定的 Sector（比如 Sector 0）放一些元数据，元数据里注明了其他的 Sector（从 1 开始的其它 sector）分别用于什么用途，然后 NDEF 是其中一种用途。这个结构叫做 <a href=\"https://www.nxp.com.cn/docs/en/application-note/AN10787.pdf\">MIFARE Application Directory</a>。具体来说，在 MIFARE Classic 里面，它规定 Block 1 和 Block 2 的内容如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">0-1</th>\n<th align=\"left\">2-3</th>\n<th align=\"left\">4-5</th>\n<th align=\"left\">6-7</th>\n<th align=\"left\">8-9</th>\n<th align=\"left\">10-11</th>\n<th align=\"left\">12-13</th>\n<th align=\"left\">14-15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Info &amp; CRC</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n</tr>\n<tr>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n</tr>\n</tbody></table>\n<p>第一个字节是 CRC 8，它的定义可以在这里的 <a href=\"https://reveng.sourceforge.io/crc-catalogue/1-15.htm\">CRC-8&#x2F;MIFARE-MAD</a> 里找到：初始值 0xC7，多项式上 0x1D。参与 CRC 计算的是按顺序从第二个字节开始的 31 个字节。</p>\n<p>第二个字节是 Info Byte，用处不大，见 MAD 的文档。</p>\n<p>之后每两个字节对应一个 Sector 的 AID（Application ID），比如 Block 1 的 2-3 字节对应 Sector 1 的 AID，Block 1 的 4-5 字节对应 Sector 2 的 AID，最后 Block 2 的 14-15 字节对应 Sector 15 的 AID。NDEF 的 AID 就是 0x03 0xE1。当软件发现这里的 AID 是 0x03E1 的时候，它就会去相应的 Sector 去读取 NDEF 信息。</p>\n<p>省流助手：[0x14 0x01]可以理解为标记扇区0为索引，[0x03 0xE1]可以理解为标记扇区为NDEF消息储存空间。所以一个将NDEF信息记录在Mifare Classic标签上的数据形式大概类似这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sector0</span><br><span class=\"line\">    Block0 E7 CA C1 B3 5F 08 04 00 02 78 B1 F6 C9 6F FA 1D（芯片ID与厂商信息）</span><br><span class=\"line\">    Block1 14 01 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1（相当于所有扇区的类型索引）</span><br><span class=\"line\">    Block2 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 14 01（相当于所有扇区的类型索引）</span><br><span class=\"line\">    Block3 A0 A1 A2 A3 A4 A5 78 77 88 C1 B0 B1 B2 B3 B4 B5（密钥A：A0A1A2A3A4A5 控制位：787788[表示扇区0密钥A只读，密钥B读写] C1[C1实际上不参与控制，可以用来替换成其他的内容保存用户数据] 密钥B：B0B1B2B3B4B5）</span><br><span class=\"line\">Sector1</span><br><span class=\"line\">    Block0 48 45 4C 4C 4F 59 4F 52 4C 44 00 00 00 00 00 00（自定义的数据内容，翻译：HELLOWORLD）</span><br><span class=\"line\">    Block1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）</span><br><span class=\"line\">    Block2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）</span><br><span class=\"line\">    Block3 FF FF FF FF FF FF 78 77 88 C1 FF FF FF FF FF FF（密钥与控制位）</span><br><span class=\"line\">Sector2</span><br><span class=\"line\">    Block0</span><br><span class=\"line\">    Block1</span><br><span class=\"line\">    Block2</span><br><span class=\"line\">    Block3</span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">Sector16</span><br><span class=\"line\">    Block0</span><br><span class=\"line\">    Block1</span><br><span class=\"line\">    Block2</span><br><span class=\"line\">    Block3</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过微信小程序读写标签\"><a href=\"#通过微信小程序读写标签\" class=\"headerlink\" title=\"通过微信小程序读写标签\"></a>通过微信小程序读写标签</h2><p>以上内容，主要是基础知识的补充，下面是真正的干货demo</p>\n<p><a href=\"https://github.com/MangK/NFCTools-MiniProgram\">这里是我开源的用来对MifareClassic芯片（M1芯片）进行读写的项目</a></p>\n<h2 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h2><blockquote>\n<p>再次感谢以上文章引用中提到的博主与作者！！！</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>最近的项目需求中，需要使用NFC芯片来保存一些类似于url的信息并通过iOS或Android手机能正常获取到相关信息，所以针对NFC相关技术与特点进行了学习和总结。我会把我看过教程链接也同步贴到文章中。因为手上只有M1卡，所以下面的主要内容也围绕M1卡来进行</p>\n<h2 id=\"什么是NFC\"><a href=\"#什么是NFC\" class=\"headerlink\" title=\"什么是NFC\"></a>什么是NFC</h2><p>近场通信（英语：Near-field communication，NFC），又称近距离无线通信、近距离通信，是一套通信协议，让两个电子设备（其中一个通常是移动设备，例如智能手机）在相距几厘米之内进行通信。NFC，如同过去的电子票券智能卡一般，将允许移动支付取代或支持这类系统。NFC应用于社交网络，分享联系方式、照片、视频或文件。具备 NFC 功能的设备可以充当电子身份证和钥匙卡。NFC 提供了设置简便的低速连接，也可用于引导能力更强的无线连接。</p>\n<p>近场通信技术由非接触式射频识别（RFID）演变而来，由飞利浦半导体（现恩智浦半导体）、诺基亚和索尼共同于2004年研制开发，其基础是RFID及互连技术。近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。目前近场通信已通过成为ISO&#x2F;IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。NFC采用主动和被动两种读取模式。</p>\n<p>每一个完整的NFC设备可以用三种模式工作：</p>\n<ul>\n<li>卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备（如手机）没电也可以工作。NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全组件（Security Element, SE）之NFC芯片或通过软件实现主机卡模拟(Host Card Emulation，HCE)。</li>\n<li>读卡器模式（Reader&#x2F;Writer mode）：作为非接触读卡器使用，比如从海报或者展览信息电子标签上读取相关信息。</li>\n<li>点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。因此通过NFC，多个设备如数位相机、PDA、计算机和手机之间都可以交换资料或者服务。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/zh-cn/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A\">维基百科-近场通信</a><br><a href=\"https://baike.baidu.com/item/%E8%BF%91%E5%9C%BA%E9%80%9A%E4%BF%A1/9741433?fromtitle=nfc&fromid=5684&fr=aladdin\">百度-NFC</a></p>\n</blockquote>\n<h2 id=\"各种NFC卡的区别\"><a href=\"#各种NFC卡的区别\" class=\"headerlink\" title=\"各种NFC卡的区别\"></a>各种NFC卡的区别</h2><table>\n<thead>\n<tr>\n<th align=\"left\">卡</th>\n<th align=\"left\">功能描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">普通IC卡</td>\n<td align=\"left\">0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。</td>\n</tr>\n<tr>\n<td align=\"left\">UID 卡</td>\n<td align=\"left\">普通复制卡，可以重复擦写所有扇区，主要应用在IC卡复制上，遇到带有防火墙的读卡器就会失效。</td>\n</tr>\n<tr>\n<td align=\"left\">CUID 卡</td>\n<td align=\"left\">可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。</td>\n</tr>\n<tr>\n<td align=\"left\">FUID 卡</td>\n<td align=\"left\">不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。</td>\n</tr>\n<tr>\n<td align=\"left\">UFUID 卡</td>\n<td align=\"left\">高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/351266514\">知乎-司小凯-UID卡、IC卡、ID卡、CUID 卡、FUID 卡、UFUID 卡 的区别</a></p>\n</blockquote>\n<h2 id=\"NFC标签类型\"><a href=\"#NFC标签类型\" class=\"headerlink\" title=\"NFC标签类型\"></a>NFC标签类型</h2><p>目前iOS系统并没有开放过多的NFC权限，所以这里讨论通过Android系统操作NFC标签，以下是Android系统操作NFC标签支持的标签技术类型</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Class</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">TagTechnology</td>\n<td align=\"left\">这是所有标签技术类都必须实现的接口。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcA</td>\n<td align=\"left\">提供对 NFC-A (ISO 14443-3A) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcB</td>\n<td align=\"left\">提供对 NFC-B (ISO 14443-3B) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcF</td>\n<td align=\"left\">提供对 NFC-F (JIS 6319-4) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NfcV</td>\n<td align=\"left\">提供对 NFC-V (ISO 15693) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">IsoDep</td>\n<td align=\"left\">提供对 ISO-DEP (ISO 14443-4) 属性和 I&#x2F;O 操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">Ndef</td>\n<td align=\"left\">提供对 NDEF 格式的 NFC 标签上的 NDEF 数据和操作的访问权限。</td>\n</tr>\n<tr>\n<td align=\"left\">NdefFormatable</td>\n<td align=\"left\">为可设置为 NDEF 格式的标签提供格式化操作。</td>\n</tr>\n<tr>\n<td align=\"left\">MifareClassic</td>\n<td align=\"left\">提供对 MIFARE Classic 属性和 I&#x2F;O 操作的访问权限（如果此 Android 设备支持 MIFARE）。</td>\n</tr>\n<tr>\n<td align=\"left\">MifareUltralight</td>\n<td align=\"left\">提供对 MIFARE Ultralight 属性和 I&#x2F;O 操作的访问权限（如果此 Android 设备支持 MIFARE）。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><a href=\"https://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc?hl=zh_cn\">Android开发文档-高级NFC概览</a></p>\n</blockquote>\n<h2 id=\"NDEF数据格式\"><a href=\"#NDEF数据格式\" class=\"headerlink\" title=\"NDEF数据格式\"></a>NDEF数据格式</h2><p>这里讲的很详细：</p>\n<blockquote>\n<p><a href=\"http://article.iotxfd.cn/RFID/NDEF\">NDEF技术规范</a></p>\n</blockquote>\n<h2 id=\"Mifare-Classic标签（M1卡）\"><a href=\"#Mifare-Classic标签（M1卡）\" class=\"headerlink\" title=\"Mifare Classic标签（M1卡）\"></a>Mifare Classic标签（M1卡）</h2><p>NFC 有很多协议，其中 MIFARE Classic 基于 ISO 14443-3 Type A 标准，里面有一些 MIFARE 的命令。通过这些命令，就可以控制 MIFARE Classic 卡的内容。<a href=\"https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf\">MIFARE Classic EV1 4K S70</a></p>\n<blockquote>\n<p><a href=\"https://jia.je/hardware/2020/05/10/mifare-classic-ndef/\">杰哥的{运维,编程,调板子}小笔记-MIFARE Classic 上配置 NDEF</a></p>\n</blockquote>\n<h3 id=\"Sector-Block-标签的内存布局\"><a href=\"#Sector-Block-标签的内存布局\" class=\"headerlink\" title=\"Sector&amp;Block 标签的内存布局\"></a>Sector&amp;Block 标签的内存布局</h3><p>在 MIFARE Classic 中，有 Sector 和 Block 的概念，每个 Sector 有若干个 Block，其中最后一个 Block 是特殊的（称为 Sector Trailer），保存了这个 Sector 的一些信息：Key A、Access Bits、GPB 和 Key B。对于 Classic 4K，首先是 32 个有 4 blocks 的 sector，（M1卡）整体的内存布局大概是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sector 0:</span><br><span class=\"line\">\tBlock 0 (出厂时写入了标签ID，厂商信息等，不可修改)</span><br><span class=\"line\">\tBlock 1</span><br><span class=\"line\">\tBlock 2</span><br><span class=\"line\">\tBlock 3(Sector Trailer)</span><br><span class=\"line\">Sector 1:</span><br><span class=\"line\">\tBlock 4</span><br><span class=\"line\">\tBlock 5</span><br><span class=\"line\">\tBlock 6</span><br><span class=\"line\">\tBlock 7(Sector Trailer)</span><br><span class=\"line\">...</span><br><span class=\"line\">Sector 15:</span><br><span class=\"line\">\tBlock 60</span><br><span class=\"line\">\tBlock 61</span><br><span class=\"line\">\tBlock 62</span><br><span class=\"line\">\tBlock 63(Sector Trailer)</span><br></pre></td></tr></table></figure>\n<p>Sector Trailer 的布局如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Key A</th>\n<th align=\"left\">Access Bits</th>\n<th align=\"left\">GPB</th>\n<th align=\"left\">Key B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">6字节</td>\n<td align=\"left\">3字节</td>\n<td align=\"left\">1字节</td>\n<td align=\"left\">6字节</td>\n</tr>\n</tbody></table>\n<h3 id=\"A、B密钥与控制位\"><a href=\"#A、B密钥与控制位\" class=\"headerlink\" title=\"A、B密钥与控制位\"></a>A、B密钥与控制位</h3><p>其中Access Bits（控制位）决定了密钥A、B对每个Block的读写权限，关于控制位详解参见：</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/hanlinhe111/article/details/121100198\">CSDN-小流氓哥哥-IC卡 M1卡 各个扇区 控制块 密码 详解</a></p>\n</blockquote>\n<h3 id=\"读取写入等操作命令\"><a href=\"#读取写入等操作命令\" class=\"headerlink\" title=\"读取写入等操作命令\"></a>读取写入等操作命令</h3><ul>\n<li>认证：<br>  一条认证指令：0x60 0x05 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF（0x60：使用密钥A[0x61：使用密钥B]，0x05：sector1-block1就是指从0开始编号的第n个块，后面6个16进制数即是密钥A）</li>\n<li>读取：<br>  一条读取指令：0x30 0x05 （0x30：读取命令，0x05：sector1-block1就是指从0开始编号的第n个块）<br>  这里是要读取扇区1块0的内容</li>\n<li>写入：<br>  一条写入指令：0xA0 0x06 0x64 0x6C 0x2F 0x62 0x75 0x73 0x69 0x6E 0x65 0x73 0x73 0x2F 0x3F 0x74 0x3D 0x6E（0xA0：写入命令，0x06：sector1-block2就是指从0开始编号的第n个块，后面为16个16进制数组成的要写入的内容）<br>  这里要写入扇区1块1的内容为：646C2F627573696E6573732F3F743D6E</li>\n<li>内容格式：<br>  文字内容需要将文字对应的Ascii码值转化为16进制</li>\n</ul>\n<p>借用微信的能力使用小程序对NFC标签进行读写的时候需要将命令内容转化为二进制内容：</p>\n<blockquote>\n<p><a href=\"https://developers.weixin.qq.com/community/develop/doc/0004e61e77ccb8187a5b325415b400\">微信开放社区提问的评论内容</a></p>\n</blockquote>\n<h3 id=\"认证与读写流程\"><a href=\"#认证与读写流程\" class=\"headerlink\" title=\"认证与读写流程\"></a>认证与读写流程</h3><p>针对扇区的读取与写入操作都需要使用密钥进行验证，验证成功后就可以执行相关的读写命令</p>\n<h2 id=\"NDEF-on-Mifare-Classic\"><a href=\"#NDEF-on-Mifare-Classic\" class=\"headerlink\" title=\"NDEF on Mifare Classic\"></a>NDEF on Mifare Classic</h2><p>NDEF 只定义了数据格式，但为了实际使用，还得看具体情况。就好像文件内容保存在硬盘上的时候，并不是直接保存，而是通过文件系统，人为定义一个路径，这样大家才知道要从 &#x2F;etc&#x2F;shadow 文件去读 Linux 的用户密码信息，NDEF 也需要人为定义一些规则，再作为数据存放在智能卡里的某个地方，这样大家去读取 metadata，发现上 NDEF Tag，然后才会去解析 NDEF 信息。</p>\n<p>有些时候，这个定义很简单，比如直接把 NDEF 数据放在某个 block 里面；有的时候又很复杂，因为可能同时存在很多应用，NDEF 只是其中的一种，所以要有一种类似目录的东西去索引 NDEF“文件”。</p>\n<p>MIFARE Classic 上采用的方法上，在特定的 Sector（比如 Sector 0）放一些元数据，元数据里注明了其他的 Sector（从 1 开始的其它 sector）分别用于什么用途，然后 NDEF 是其中一种用途。这个结构叫做 <a href=\"https://www.nxp.com.cn/docs/en/application-note/AN10787.pdf\">MIFARE Application Directory</a>。具体来说，在 MIFARE Classic 里面，它规定 Block 1 和 Block 2 的内容如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">0-1</th>\n<th align=\"left\">2-3</th>\n<th align=\"left\">4-5</th>\n<th align=\"left\">6-7</th>\n<th align=\"left\">8-9</th>\n<th align=\"left\">10-11</th>\n<th align=\"left\">12-13</th>\n<th align=\"left\">14-15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Info &amp; CRC</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n</tr>\n<tr>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n<td align=\"left\">AID</td>\n</tr>\n</tbody></table>\n<p>第一个字节是 CRC 8，它的定义可以在这里的 <a href=\"https://reveng.sourceforge.io/crc-catalogue/1-15.htm\">CRC-8&#x2F;MIFARE-MAD</a> 里找到：初始值 0xC7，多项式上 0x1D。参与 CRC 计算的是按顺序从第二个字节开始的 31 个字节。</p>\n<p>第二个字节是 Info Byte，用处不大，见 MAD 的文档。</p>\n<p>之后每两个字节对应一个 Sector 的 AID（Application ID），比如 Block 1 的 2-3 字节对应 Sector 1 的 AID，Block 1 的 4-5 字节对应 Sector 2 的 AID，最后 Block 2 的 14-15 字节对应 Sector 15 的 AID。NDEF 的 AID 就是 0x03 0xE1。当软件发现这里的 AID 是 0x03E1 的时候，它就会去相应的 Sector 去读取 NDEF 信息。</p>\n<p>省流助手：[0x14 0x01]可以理解为标记扇区0为索引，[0x03 0xE1]可以理解为标记扇区为NDEF消息储存空间。所以一个将NDEF信息记录在Mifare Classic标签上的数据形式大概类似这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sector0</span><br><span class=\"line\">    Block0 E7 CA C1 B3 5F 08 04 00 02 78 B1 F6 C9 6F FA 1D（芯片ID与厂商信息）</span><br><span class=\"line\">    Block1 14 01 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1（相当于所有扇区的类型索引）</span><br><span class=\"line\">    Block2 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 03 E1 14 01（相当于所有扇区的类型索引）</span><br><span class=\"line\">    Block3 A0 A1 A2 A3 A4 A5 78 77 88 C1 B0 B1 B2 B3 B4 B5（密钥A：A0A1A2A3A4A5 控制位：787788[表示扇区0密钥A只读，密钥B读写] C1[C1实际上不参与控制，可以用来替换成其他的内容保存用户数据] 密钥B：B0B1B2B3B4B5）</span><br><span class=\"line\">Sector1</span><br><span class=\"line\">    Block0 48 45 4C 4C 4F 59 4F 52 4C 44 00 00 00 00 00 00（自定义的数据内容，翻译：HELLOWORLD）</span><br><span class=\"line\">    Block1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）</span><br><span class=\"line\">    Block2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（没有填写内容）</span><br><span class=\"line\">    Block3 FF FF FF FF FF FF 78 77 88 C1 FF FF FF FF FF FF（密钥与控制位）</span><br><span class=\"line\">Sector2</span><br><span class=\"line\">    Block0</span><br><span class=\"line\">    Block1</span><br><span class=\"line\">    Block2</span><br><span class=\"line\">    Block3</span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">Sector16</span><br><span class=\"line\">    Block0</span><br><span class=\"line\">    Block1</span><br><span class=\"line\">    Block2</span><br><span class=\"line\">    Block3</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过微信小程序读写标签\"><a href=\"#通过微信小程序读写标签\" class=\"headerlink\" title=\"通过微信小程序读写标签\"></a>通过微信小程序读写标签</h2><p>以上内容，主要是基础知识的补充，下面是真正的干货demo</p>\n<p><a href=\"https://github.com/MangK/NFCTools-MiniProgram\">这里是我开源的用来对MifareClassic芯片（M1芯片）进行读写的项目</a></p>\n<h2 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h2><blockquote>\n<p>再次感谢以上文章引用中提到的博主与作者！！！</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clowjpr1f0001ikfydx19cn3x","category_id":"clowjpr1h0003ikfyamqxc95n","_id":"clowjpr1k000aikfy9gbr59vw"},{"post_id":"clowjpr1i0004ikfy7o2rdkqq","category_id":"clowjpr1k0007ikfy2c6s67oy","_id":"clowjpr1l000dikfyfal20vuz"},{"post_id":"clowjpr1j0006ikfya703cu50","category_id":"clowjpr1k000bikfy5mfz5pon","_id":"clowjpr1l000fikfyhxda6ww0"},{"post_id":"clowjpr1l000iikfy42cv623k","category_id":"clowjpr1h0003ikfyamqxc95n","_id":"clowjpr1m000kikfy63k7dbb8"},{"post_id":"clowjpr49000likfyen9z5ymd","category_id":"clowjpr1k000bikfy5mfz5pon","_id":"clowjpr4a000nikfy38hfgl0f"},{"post_id":"clowjpr4c000qikfy3e4idllr","category_id":"clowjpr1k000bikfy5mfz5pon","_id":"clowjpr4d000tikfyb6el2zuf"},{"post_id":"clowjpr4c000rikfy77v9e08n","category_id":"clowjpr1k0007ikfy2c6s67oy","_id":"clowjpr4e000uikfy243x8x14"}],"PostTag":[{"post_id":"clowjpr1g0002ikfyajld7o1e","tag_id":"clowjpr1i0005ikfy1ga16aeg","_id":"clowjpr1k0009ikfy67dw6w2g"},{"post_id":"clowjpr1j0006ikfya703cu50","tag_id":"clowjpr1k0008ikfy97djhc8o","_id":"clowjpr1l000eikfy2z9u145n"},{"post_id":"clowjpr1j0006ikfya703cu50","tag_id":"clowjpr1l000cikfycv8r5tu2","_id":"clowjpr1l000gikfyb68z8sfg"},{"post_id":"clowjpr1l000iikfy42cv623k","tag_id":"clowjpr1k0008ikfy97djhc8o","_id":"clowjpr1m000jikfyd06fes3d"},{"post_id":"clowjpr49000likfyen9z5ymd","tag_id":"clowjpr1k0008ikfy97djhc8o","_id":"clowjpr4a000oikfyfce9ajov"},{"post_id":"clowjpr49000likfyen9z5ymd","tag_id":"clowjpr4a000mikfy0rl8ak5h","_id":"clowjpr4a000pikfy27ub9zjt"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr1k0008ikfy97djhc8o","_id":"clowjpr4e000yikfyc9qgcjgq"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr4d000sikfyh1jid2gc","_id":"clowjpr4e000zikfyhryad0y5"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr1l000cikfycv8r5tu2","_id":"clowjpr4f0011ikfy07f1gaj7"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr4e000vikfy3dh1htzb","_id":"clowjpr4f0012ikfy5s3u0b91"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr4e000wikfy5n8idsy3","_id":"clowjpr4f0014ikfy4cr6025l"},{"post_id":"clowjpr4c000qikfy3e4idllr","tag_id":"clowjpr4a000mikfy0rl8ak5h","_id":"clowjpr4f0015ikfyfn4w3elt"},{"post_id":"clowjpr4c000rikfy77v9e08n","tag_id":"clowjpr4e000xikfy2h365n0i","_id":"clowjpr4f0016ikfy28e15yeh"},{"post_id":"clowjpr4c000rikfy77v9e08n","tag_id":"clowjpr4e0010ikfy5h9s5a20","_id":"clowjpr4f0017ikfyew6mc7om"},{"post_id":"clowjpr4c000rikfy77v9e08n","tag_id":"clowjpr4f0013ikfy0wjo5vyt","_id":"clowjpr4f0018ikfy1awg7r5y"}],"Tag":[{"name":"Server","_id":"clowjpr1i0005ikfy1ga16aeg"},{"name":"Golang","_id":"clowjpr1k0008ikfy97djhc8o"},{"name":"embed","_id":"clowjpr1l000cikfycv8r5tu2"},{"name":"GUI","_id":"clowjpr4a000mikfy0rl8ak5h"},{"name":"webview","_id":"clowjpr4d000sikfyh1jid2gc"},{"name":"vue","_id":"clowjpr4e000vikfy3dh1htzb"},{"name":"gin","_id":"clowjpr4e000wikfy5n8idsy3"},{"name":"NFC","_id":"clowjpr4e000xikfy2h365n0i"},{"name":"Ndef","_id":"clowjpr4e0010ikfy5h9s5a20"},{"name":"MifareClassic","_id":"clowjpr4f0013ikfy0wjo5vyt"}]}}